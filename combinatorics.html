
<!DOCTYPE html>

<html>
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>20. Combinatorics &#8212; Logic and Proof 3.18.4 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="21. The Real Numbers" href="the_real_numbers.html" />
    <link rel="prev" title="19. Elementary Number Theory" href="elementary_number_theory.html" />
<!-- <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=Average" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> -->

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="combinatorics">
<span id="id1"></span><h1><span class="section-number">20. </span>Combinatorics<a class="headerlink" href="#combinatorics" title="Permalink to this headline">&#182;</a></h1>
<p>Combinatorics is the art of counting without counting. It is a fundamental mathematical task to determine how many things there are in a given collection, and when the collection is large, it can be tedious or infeasible to count the elements individually. Moreover, when the collection is described in terms of a changing parameter (say, a natural number, <span class="math notranslate nohighlight">\(n\)</span>), we would like a formula that tells us how the number of objects depends on that parameter. In this chapter we will set up a foundation for achieving this goal, and learn some of the tricks of the
trade.</p>
<div class="section" id="finite-sets-and-cardinality">
<h2><span class="section-number">20.1. </span>Finite Sets and Cardinality<a class="headerlink" href="#finite-sets-and-cardinality" title="Permalink to this headline">&#182;</a></h2>
<p>It will be helpful, for every natural number <span class="math notranslate nohighlight">\(n\)</span>, to have a canonical set of elements of size <span class="math notranslate nohighlight">\(n\)</span>. To that end, we will choose the set</p>
<div class="math notranslate nohighlight">
\[[n] = \{ m \mid m &lt; n \} = \{ 0, 1, \ldots, n-1 \}.\]</div>
<p>We used the same notation, <span class="math notranslate nohighlight">\([n]\)</span>, to describe equivalence classes with respect to an equivalence relation, but hopefully our intended meaning will always be clear from the context.</p>
<p>A set <span class="math notranslate nohighlight">\(A\)</span> of elements is said to be <em>finite</em> if there is a bijection from <span class="math notranslate nohighlight">\([n]\)</span> to <span class="math notranslate nohighlight">\(A\)</span> for some <span class="math notranslate nohighlight">\(n\)</span>. In that case, we would like to say that <span class="math notranslate nohighlight">\(A\)</span> <em>has</em> <span class="math notranslate nohighlight">\(n\)</span> <em>elements</em>, or that the set <span class="math notranslate nohighlight">\(A\)</span> <em>has cardinality</em> <span class="math notranslate nohighlight">\(n\)</span>, and write <span class="math notranslate nohighlight">\(|A| = n\)</span>. But to do so, we need to know that when <span class="math notranslate nohighlight">\(A\)</span> is finite, there is a unique <span class="math notranslate nohighlight">\(n\)</span> with the property above.</p>
<p>Suppose there are bijections from both <span class="math notranslate nohighlight">\([m]\)</span> and <span class="math notranslate nohighlight">\([n]\)</span> to <span class="math notranslate nohighlight">\(A\)</span>. Composing the first bijection with the inverse of the second, we get a bijection from <span class="math notranslate nohighlight">\([m]\)</span> to <span class="math notranslate nohighlight">\([n]\)</span>. It seems intuitively clear that this implies <span class="math notranslate nohighlight">\(m = n\)</span>, but our goal is to prove this from the fundamental properties of sets, functions, and the natural numbers.</p>
<p>So suppose, for the sake of contradiction, <span class="math notranslate nohighlight">\(m \neq n\)</span>. Without loss of generality, we can assume <span class="math notranslate nohighlight">\(m &gt; n\)</span> (why?). In particular, there is an injective function <span class="math notranslate nohighlight">\(f\)</span> from <span class="math notranslate nohighlight">\([m]\)</span> to <span class="math notranslate nohighlight">\([n]\)</span>. Since <span class="math notranslate nohighlight">\(m &gt; n\)</span>, <span class="math notranslate nohighlight">\(m \geq n+1\)</span>, and so we can restrict <span class="math notranslate nohighlight">\(f\)</span> to get an injective function from <span class="math notranslate nohighlight">\([n+1]\)</span> to <span class="math notranslate nohighlight">\([n]\)</span>. The next theorem shows that this cannot happen.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> For any natural number <span class="math notranslate nohighlight">\(n\)</span>, there is no injective function from <span class="math notranslate nohighlight">\([n+1]\)</span> to <span class="math notranslate nohighlight">\([n]\)</span>.</p>
<p><strong>Proof.</strong> By induction on <span class="math notranslate nohighlight">\(n\)</span>. The theorem is clear when <span class="math notranslate nohighlight">\(n = 0\)</span>, because <span class="math notranslate nohighlight">\([1] = \{ 0 \}\)</span> and <span class="math notranslate nohighlight">\([0] = \emptyset\)</span>. If <span class="math notranslate nohighlight">\(f\)</span> were an injective function from <span class="math notranslate nohighlight">\([1]\)</span> to <span class="math notranslate nohighlight">\([0]\)</span>, we would have <span class="math notranslate nohighlight">\(f(0) \in \emptyset\)</span>, which is impossible.</p>
<p>So suppose the claim is true for <span class="math notranslate nohighlight">\(n\)</span>, and suppose <span class="math notranslate nohighlight">\(f\)</span> is an injective function from <span class="math notranslate nohighlight">\([n+2]\)</span> to <span class="math notranslate nohighlight">\([n+1]\)</span>. We consider two cases.</p>
<p>In the first case, suppose <span class="math notranslate nohighlight">\(n\)</span> is not in the image of <span class="math notranslate nohighlight">\(f\)</span>. Then <span class="math notranslate nohighlight">\(f\)</span> maps <span class="math notranslate nohighlight">\([n+2]\)</span> to <span class="math notranslate nohighlight">\([n]\)</span>, and restricting the domain, we have an injective function from <span class="math notranslate nohighlight">\([n+1]\)</span> to <span class="math notranslate nohighlight">\([n]\)</span>, contradicting the inductive hypothesis.</p>
<p>In the second case, there is some <span class="math notranslate nohighlight">\(m &lt; n + 2\)</span> such that <span class="math notranslate nohighlight">\(f(m) = n\)</span>. The idea is to alter <span class="math notranslate nohighlight">\(f\)</span> slightly to get an injective function from <span class="math notranslate nohighlight">\([n+1]\)</span> to <span class="math notranslate nohighlight">\([n]\)</span>, again contradicting the inductive hypothesis. If <span class="math notranslate nohighlight">\(m = n + 1\)</span>, which is to say it is the last element of <span class="math notranslate nohighlight">\([n+2]\)</span> that is mapped to the last element of <span class="math notranslate nohighlight">\([n+1]\)</span>, we can just restrict <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\([n+1]\)</span>. The fact that <span class="math notranslate nohighlight">\(f\)</span> was injective implies that all the elements in <span class="math notranslate nohighlight">\([n+1]\)</span> are mapped to <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Otherwise, define <span class="math notranslate nohighlight">\(f' : [n+1] \to [n]\)</span> by</p>
<div class="math notranslate nohighlight">
\[\begin{split}f'(i) =
  \begin{cases}
    f(i) &amp; \mbox{if $i \neq m$} \\
    f(n+1) &amp; \mbox{if $i = m$.}
  \end{cases}\end{split}\]</div>
<p>In other words, we map <span class="math notranslate nohighlight">\(m\)</span> to the value that <span class="math notranslate nohighlight">\(n+1\)</span> was mapped to. Since <span class="math notranslate nohighlight">\(f\)</span> is injective, <span class="math notranslate nohighlight">\(f(n+1) \neq f(m)\)</span>, and so <span class="math notranslate nohighlight">\(f(n+1) &lt; n\)</span>, as required. It is not hard to check that <span class="math notranslate nohighlight">\(f'\)</span> is injective, so we have the contradiction we were after.</p>
<hr class="docutils" />
<p>This theorem is known as the &#8220;pigeonhole principle.&#8221; It implies that if <span class="math notranslate nohighlight">\(n + 1\)</span> pigeons inhabit <span class="math notranslate nohighlight">\(n\)</span> holes, then at least one hole has more than one pigeon. The principle implies that for every finite set <span class="math notranslate nohighlight">\(A\)</span>, there is a unique <span class="math notranslate nohighlight">\(n\)</span> such that there is a bijection from <span class="math notranslate nohighlight">\([n]\)</span> to <span class="math notranslate nohighlight">\(A\)</span>, and we can define the cardinality of <span class="math notranslate nohighlight">\(A\)</span> to be that <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>We now introduce the notation <span class="math notranslate nohighlight">\(\sum_{i \in A} f(i)\)</span> and <span class="math notranslate nohighlight">\(\prod_{i \in A} f(i)\)</span> for sums and products over finite sets. If <span class="math notranslate nohighlight">\(A = \{ a_0, \ldots, a_{n-1} \}\)</span>, then <span class="math notranslate nohighlight">\(\sum_{i \in A} f(i)\)</span> is defined to be <span class="math notranslate nohighlight">\(f(a_0) + \cdots + f(a_{n-1})\)</span>, and similarly for products. Formally, what we are doing is choosing a bijection <span class="math notranslate nohighlight">\(g : [n] \to A\)</span> and defining <span class="math notranslate nohighlight">\(\sum_{i \in A} f(i)\)</span> to be <span class="math notranslate nohighlight">\(\sum_{j &lt; n} f(g(j))\)</span>. It takes some work to show that this makes sense, which is to say, the answer we get doesn&#8217;t depend on which bijection we choose. We will just take this fact for granted here.</p>
</div>
<div class="section" id="counting-principles">
<span id="id2"></span><h2><span class="section-number">20.2. </span>Counting Principles<a class="headerlink" href="#counting-principles" title="Permalink to this headline">&#182;</a></h2>
<p>Here is a basic counting principle.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be disjoint finite sets. Then <span class="math notranslate nohighlight">\(| A \cup B | = | A | + | B |\)</span>.</p>
<p><strong>Proof.</strong> Suppose <span class="math notranslate nohighlight">\(f : [m] \to A\)</span> and <span class="math notranslate nohighlight">\(g : [n] \to B\)</span> are bijections. Define <span class="math notranslate nohighlight">\(h : [m + n] \to A \cup B\)</span> by</p>
<div class="math notranslate nohighlight">
\[\begin{split}h(i) =
  \begin{cases}
    f(i) &amp; \mbox{if $i &lt; m$} \\
    g(i - m) &amp; \mbox{if $m \leq i &lt; m + n$.}
  \end{cases}\end{split}\]</div>
<p>To see that <span class="math notranslate nohighlight">\(h\)</span> is surjective, note that every <span class="math notranslate nohighlight">\(k\)</span> in <span class="math notranslate nohighlight">\(A \cup B\)</span> can be written as either <span class="math notranslate nohighlight">\(k = f(i)\)</span> for some <span class="math notranslate nohighlight">\(i \in [m]\)</span> or <span class="math notranslate nohighlight">\(k = g(j)\)</span> for some <span class="math notranslate nohighlight">\(j \in [n]\)</span>. In the first case, <span class="math notranslate nohighlight">\(k = f(i) = h(i)\)</span>, and in the second case, <span class="math notranslate nohighlight">\(k = g(j) = h(m + j)\)</span>.</p>
<p>It is not hard to show that <span class="math notranslate nohighlight">\(h\)</span> is also injective. Suppose <span class="math notranslate nohighlight">\(h(i) = h(j)\)</span>. If <span class="math notranslate nohighlight">\(h(i)\)</span> is in <span class="math notranslate nohighlight">\(A\)</span>, then it is not in the range of <span class="math notranslate nohighlight">\(g\)</span>, and so we must have <span class="math notranslate nohighlight">\(h(i) = f(i)\)</span> and <span class="math notranslate nohighlight">\(h(j) = f(j)\)</span>. Then <span class="math notranslate nohighlight">\(f(i) = f(j)\)</span>, the injectivity of <span class="math notranslate nohighlight">\(f\)</span> implies that <span class="math notranslate nohighlight">\(i = j\)</span>. If <span class="math notranslate nohighlight">\(h(i)\)</span> is instead in <span class="math notranslate nohighlight">\(B\)</span>, the argument it similar.</p>
<hr class="docutils" />
<p>The proof only spells out our basic intuitions: if you want to list all of the elements of <span class="math notranslate nohighlight">\(A \cup B\)</span>, you can list all the elements of <span class="math notranslate nohighlight">\(A\)</span> and then all the elements of <span class="math notranslate nohighlight">\(B\)</span>. And if <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> have no elements in common, then to count the elements of <span class="math notranslate nohighlight">\(A \cup B\)</span>, you can count the elements of <span class="math notranslate nohighlight">\(A\)</span> and then continue counting the elements of <span class="math notranslate nohighlight">\(B\)</span>. Once you are comfortable translating the intuitive argument into a precise mathematical proof (and mathematicians generally are), you can use the more intuitive descriptions (and mathematicians generally do).</p>
<p>Here is another basic counting principle:</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be finite sets. Then <span class="math notranslate nohighlight">\(| A \times B | = | A | \cdot | B |\)</span>.</p>
<hr class="docutils" />
<p>Notice that this time we are counting the number of ordered pairs <span class="math notranslate nohighlight">\((a, b)\)</span> with <span class="math notranslate nohighlight">\(a \in A\)</span> and <span class="math notranslate nohighlight">\(b \in B\)</span>. The exercises ask you to give a detailed proof of this theorem. There are at least two ways to go about it. The first is to start with bijections <span class="math notranslate nohighlight">\(f : [m] \to A\)</span> and <span class="math notranslate nohighlight">\(g : [n] \to B\)</span> and describe an explicit bijection <span class="math notranslate nohighlight">\(h : [m \cdot n] \to A \times B\)</span>. The second is to fix <span class="math notranslate nohighlight">\(m\)</span>, say, and use induction on <span class="math notranslate nohighlight">\(n\)</span> and the previous counting principle. Notice that if <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(V\)</span> are any sets and <span class="math notranslate nohighlight">\(w\)</span> is not in <span class="math notranslate nohighlight">\(V\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[U \times (V \cup \{ w \}) = (U \times V) \cup (U \times \{w\}),\]</div>
<p>and the two sets in this union are disjoint.</p>
<p>Just as we have notions of union <span class="math notranslate nohighlight">\(\bigcup_{i\in I} A_i\)</span> and intersection <span class="math notranslate nohighlight">\(\bigcap_{i \in I} A_i\)</span> for indexed families of sets, it is useful to have a notion of a product <span class="math notranslate nohighlight">\(\prod_{i \in I} A_i\)</span>. We can think of an element <span class="math notranslate nohighlight">\(a\)</span> of this product as a function which, for each element <span class="math notranslate nohighlight">\(i \in I\)</span>, returns an element <span class="math notranslate nohighlight">\(a_i \in A_i\)</span>. For example, when <span class="math notranslate nohighlight">\(I = \{1, 2, 3\}\)</span>, an element of <span class="math notranslate nohighlight">\(\prod_{i \in I} A_i\)</span> is just a triple <span class="math notranslate nohighlight">\(a_1, a_2, a_3\)</span> with <span class="math notranslate nohighlight">\(a_1 \in A_1\)</span>, <span class="math notranslate nohighlight">\(a_2 \in A_2\)</span>, and <span class="math notranslate nohighlight">\(a_3 \in A_3\)</span>. This is essentially the same as <span class="math notranslate nohighlight">\(A_1 \times A_2 \times A_3\)</span>, up to the fiddly details as to whether we represent a triple as a function or with iterated pairing <span class="math notranslate nohighlight">\((a_1, (a_2, a_3))\)</span>.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math notranslate nohighlight">\(I\)</span> be a finite index set, and let <span class="math notranslate nohighlight">\((A_i)_{i \in I}\)</span> be a family of finite sets. Then:</p>
<ul class="simple">
<li><p>If each pair of sets <span class="math notranslate nohighlight">\(A_i\)</span>, <span class="math notranslate nohighlight">\(A_j\)</span> are disjoint, then <span class="math notranslate nohighlight">\(|\bigcup_{i \in I} A_i| = \sum_{i \in I} | A_i |\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(| \prod_{i \in I} A_i | = \prod_{i \in I} | A_i |\)</span>.</p></li>
</ul>
<p><strong>Proof.</strong> By induction on <span class="math notranslate nohighlight">\(|I|\)</span>, using the previous counting principles.</p>
<hr class="docutils" />
<p>We can already use these principles to carry out basic calculations.</p>
<hr class="docutils" />
<p><strong>Example.</strong> The dessert menu at a restaurant has four flavors of ice cream, two kinds of cake, and three kinds of pie. How many dessert choices are there?</p>
<p><strong>Solution.</strong> <span class="math notranslate nohighlight">\(4 + 2 + 3 = 9\)</span>, the cardinality of the union of the three disjoint sets.</p>
<p><strong>Example.</strong> The menu at a diner has 6 choices of appetizers, 7 choices of entr&#233;e, and 5 choices of dessert. How many choices of three-course dinners are there?</p>
<p><strong>Solution.</strong> A three-course dinner is a triple consisting of an appetizer, an entr&#233;e, and a dessert. There are therefore <span class="math notranslate nohighlight">\(6 \cdot 7 \cdot 5 = 210\)</span> options.</p>
<hr class="docutils" />
<p>A special case of the previous counting principles arises when all the sets have the same size. If <span class="math notranslate nohighlight">\(I\)</span> has cardinality <span class="math notranslate nohighlight">\(k\)</span> and each <span class="math notranslate nohighlight">\(A_i\)</span> has cardinality <span class="math notranslate nohighlight">\(n\)</span>, then the cardinality of <span class="math notranslate nohighlight">\(\bigcup_{i \in I} A_i\)</span> is <span class="math notranslate nohighlight">\(k \cdot n\)</span> if the sets are pairwise disjoint, and the cardinality of <span class="math notranslate nohighlight">\(\prod_{i \in I} A_i\)</span> is <span class="math notranslate nohighlight">\(n^k\)</span>.</p>
<hr class="docutils" />
<p><strong>Example.</strong> A deck of playing cards has four suits (diamonds, hearts, spades, and clubs) and 13 cards in each suit, for a total of <span class="math notranslate nohighlight">\(4 \cdot 13 = 52\)</span>.</p>
<p><strong>Example.</strong> A binary string of length <span class="math notranslate nohighlight">\(n\)</span> is a sequence of <span class="math notranslate nohighlight">\(n\)</span> many 0&#8217;s and 1&#8217;s. We can think of this as an element of</p>
<div class="math notranslate nohighlight">
\[\{0, 1\}^n = \prod_{i &lt; n} \{0, 1\},\]</div>
<p>so there are <span class="math notranslate nohighlight">\(2^n\)</span> many binary strings of length <span class="math notranslate nohighlight">\(n\)</span>.</p>
<hr class="docutils" />
<p>There is another counting principle that is almost too obvious to mention: if <span class="math notranslate nohighlight">\(A\)</span> is a finite set and there is a bijection between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, then <span class="math notranslate nohighlight">\(B\)</span> is also finite, and <span class="math notranslate nohighlight">\(|A| = |B|\)</span>.</p>
<hr class="docutils" />
<p><strong>Example.</strong> Consider the power set of <span class="math notranslate nohighlight">\([n]\)</span>, that is, the collection of all subsets of <span class="math notranslate nohighlight">\(\{0, 1, 2, \ldots, n-1\}\)</span>. There is a one-to-one correspondence between subsets and binary strings of length <span class="math notranslate nohighlight">\(n\)</span>, where element <span class="math notranslate nohighlight">\(i\)</span> of the string is <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(i\)</span> is in the set and <span class="math notranslate nohighlight">\(0\)</span> otherwise. As a result, we have <span class="math notranslate nohighlight">\(| \mathcal P ([n]) | = 2^n\)</span>.</p>
</div>
<hr class="docutils" />
<div class="section" id="ordered-selections">
<h2><span class="section-number">20.3. </span>Ordered Selections<a class="headerlink" href="#ordered-selections" title="Permalink to this headline">&#182;</a></h2>
<p>Let <span class="math notranslate nohighlight">\(S\)</span> be a finite set, which we will think of as being a set of options, such as items on a menu or books that can be selected from a shelf. We now turn to a family of problems in combinatorics that involves making repeated selections from that set of options. In each case, there are finitely many selections, and the order counts: there is a first choice, a second one, a third one, and so on.</p>
<p>In the first variant of the problem, you are allowed to repeat a choice. For example, if you are choosing 3 flavors from a list of 31 ice cream flavors, you can choose &#8220;chocolate, vanilla, chocolate.&#8221; This is known as <em>ordered selection with repetition</em>. If you are making <span class="math notranslate nohighlight">\(k\)</span> choices from among <span class="math notranslate nohighlight">\(n\)</span> options in <span class="math notranslate nohighlight">\(S\)</span>, such a selection is essentially a tuple <span class="math notranslate nohighlight">\((a_0, a_1, \ldots, a_{k-1})\)</span>, where each <span class="math notranslate nohighlight">\(a_i\)</span> is one of the <span class="math notranslate nohighlight">\(n\)</span> elements in <span class="math notranslate nohighlight">\(S\)</span>. In other words, the set of ways of making <span class="math notranslate nohighlight">\(k\)</span> selections from <span class="math notranslate nohighlight">\(S\)</span> with repetition is the set <span class="math notranslate nohighlight">\(S^k\)</span>, and we have seen in the last section that if <span class="math notranslate nohighlight">\(S\)</span> has cardinality <span class="math notranslate nohighlight">\(n\)</span>, the set <span class="math notranslate nohighlight">\(S^k\)</span> has cardinality <span class="math notranslate nohighlight">\(n^k\)</span>.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math notranslate nohighlight">\(S\)</span> be a set of <span class="math notranslate nohighlight">\(n\)</span> elements. Then the number of ways of making <span class="math notranslate nohighlight">\(k\)</span> selections from <span class="math notranslate nohighlight">\(S\)</span> with repetition allowed is <span class="math notranslate nohighlight">\(n^k\)</span>.</p>
<p><strong>Example.</strong> How many three-letter strings (like &#8220;xyz,&#8221; &#8220;qqa,&#8221; &#8230;) can be formed using the twenty-six letters of the alphabet?</p>
<p><strong>Solution.</strong> We have to make three selections from a set of 26 elements, for a total of <span class="math notranslate nohighlight">\(26^3 = 17,576\)</span> possibilities.</p>
<hr class="docutils" />
<p>Suppose instead we wish to make <span class="math notranslate nohighlight">\(k\)</span> ordered selections, but we are not allowed to repeat ourselves. This would arise, from example, if a museum had 26 paintings in its storeroom, and has to select three of them to put on display, ordered from left to right along a wall. There are 26 choices for the first position. Once we have made that choice, 25 remain for the second position, and then 24 remain for the third. So it seems clear that there are <span class="math notranslate nohighlight">\(26 \cdot 25 \cdot 24\)</span> arrangements overall.</p>
<p>Let us try to frame the problem in mathematical terms. We can think of an ordered selection of <span class="math notranslate nohighlight">\(k\)</span> elements from a set <span class="math notranslate nohighlight">\(S\)</span> without repetition as being an <em>injective function</em> <span class="math notranslate nohighlight">\(f\)</span> from <span class="math notranslate nohighlight">\([k]\)</span> to <span class="math notranslate nohighlight">\(S\)</span>. The element <span class="math notranslate nohighlight">\(f(0)\)</span> is the first choice; <span class="math notranslate nohighlight">\(f(1)\)</span> is the second choice, which has to be distinct from <span class="math notranslate nohighlight">\(f(0)\)</span>; <span class="math notranslate nohighlight">\(f(2)\)</span> is the third choice, which has to be distinct from <span class="math notranslate nohighlight">\(f(0)\)</span> and <span class="math notranslate nohighlight">\(f(1)\)</span>; and so on.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be finite sets, with <span class="math notranslate nohighlight">\(|A| = k\)</span> and <span class="math notranslate nohighlight">\(|B| = n\)</span>, and <span class="math notranslate nohighlight">\(k \le n\)</span>. The number of injective functions from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(n \cdot (n - 1) \cdot \ldots \cdot (n - k + 1)\)</span>.</p>
<p><strong>Proof.</strong> Using induction on <span class="math notranslate nohighlight">\(k\)</span>, we will show that for every <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>, and <span class="math notranslate nohighlight">\(n \geq k\)</span>, the claim holds. When <span class="math notranslate nohighlight">\(k = 0\)</span> there is only one injective function, namely the function with empty domain. Suppose <span class="math notranslate nohighlight">\(A\)</span> has cardinality <span class="math notranslate nohighlight">\(k + 1\)</span>, let <span class="math notranslate nohighlight">\(a_0\)</span> be any element of <span class="math notranslate nohighlight">\(A\)</span>. Then any injective function from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B\)</span> can be obtained by choosing an element <span class="math notranslate nohighlight">\(b_0\)</span> for the image of <span class="math notranslate nohighlight">\(a_0\)</span>, and then choosing an injective function from <span class="math notranslate nohighlight">\(A \setminus \{ a_0 \}\)</span> to <span class="math notranslate nohighlight">\(B \setminus \{ b_0 \}\)</span>. There are <span class="math notranslate nohighlight">\(n\)</span> choices of <span class="math notranslate nohighlight">\(b_0\)</span>, and since <span class="math notranslate nohighlight">\(| A \setminus \{ a_0 \} | = n - 1\)</span> and <span class="math notranslate nohighlight">\(|B \setminus \{ b_0 \} | = k - 1\)</span>, there are <span class="math notranslate nohighlight">\((n - 1) \cdot \ldots \cdot (n - k + 1)\)</span> choices of the injective function, by the inductive hypothesis.</p>
<p><strong>Theorem.</strong> Let <span class="math notranslate nohighlight">\(S\)</span> be a finite set, with <span class="math notranslate nohighlight">\(|S| = n\)</span>. Then the number of ways of making <span class="math notranslate nohighlight">\(k\)</span> selections from <span class="math notranslate nohighlight">\(S\)</span> without repetition allowed is <span class="math notranslate nohighlight">\(n \cdot (n - 1) \cdot \ldots \cdot (n - k + 1)\)</span>.</p>
<p><strong>Proof.</strong> This is just a restatement of the previous theorem, where <span class="math notranslate nohighlight">\(A = [k]\)</span> and <span class="math notranslate nohighlight">\(B = S\)</span>.</p>
<hr class="docutils" />
<p>If <span class="math notranslate nohighlight">\(A\)</span> is a finite set, a bijection <span class="math notranslate nohighlight">\(f\)</span> from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(A\)</span> is also called a <em>permutation</em> of <span class="math notranslate nohighlight">\(A\)</span>. The previous theorem shows that if <span class="math notranslate nohighlight">\(|A| = n\)</span> then the number of permutations of <span class="math notranslate nohighlight">\(A\)</span> is <span class="math notranslate nohighlight">\(n \cdot (n - 1) \cdot \ldots \cdot 1\)</span>. This quantity comes up so often that it has a name, <span class="math notranslate nohighlight">\(n\)</span> <em>factorial</em>, and a special notation, <span class="math notranslate nohighlight">\(n!\)</span>. If we think of the elements of <span class="math notranslate nohighlight">\(A\)</span> listed in some order, a permutation of <span class="math notranslate nohighlight">\(A\)</span> is essentially an ordered selection of <span class="math notranslate nohighlight">\(n\)</span> elements from <span class="math notranslate nohighlight">\(A\)</span> without repetition: we choose where to map the first element, then the second element, and so on. It is a useful convention to take <span class="math notranslate nohighlight">\(0!\)</span> to be equal to <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>The more general case where we are choosing only <span class="math notranslate nohighlight">\(k\)</span> elements from a set <span class="math notranslate nohighlight">\(A\)</span> is called a <span class="math notranslate nohighlight">\(k\)</span>-permutation of <span class="math notranslate nohighlight">\(A\)</span>. The theorem above says that the number of <span class="math notranslate nohighlight">\(k\)</span>-permutations of an <span class="math notranslate nohighlight">\(n\)</span>-element set is equal to <span class="math notranslate nohighlight">\(n! / (n - k)!\)</span>, because if you expand the numerator and denominator into products and cancel, you get exactly the <span class="math notranslate nohighlight">\(n \cdot (n - 1) \cdot \ldots \cdot (n - k + 1)\)</span>. This number is often denoted <span class="math notranslate nohighlight">\(P(n, k)\)</span> or <span class="math notranslate nohighlight">\(P^n_k\)</span>, or some similar variant. So we have <span class="math notranslate nohighlight">\(P(n, k) = n! / (n - k)!\)</span>. Notice that the expression on the right side of the equality provides an efficient way of writing the value of <span class="math notranslate nohighlight">\(P(n, k)\)</span>, but an inefficient way of calculating it.</p>
</div>
<div class="section" id="combinations-and-binomial-coefficients">
<span id="id3"></span><h2><span class="section-number">20.4. </span>Combinations and Binomial Coefficients<a class="headerlink" href="#combinations-and-binomial-coefficients" title="Permalink to this headline">&#182;</a></h2>
<p>In the last section, we calculated the number of ways in which a museum could arrange three paintings along a wall, chosen from among 26 paintings in its storeroom. By the final observation in the previous section, we can write this number as <span class="math notranslate nohighlight">\(26! / 23!\)</span>.</p>
<p>Suppose now we want to calculate the number of ways that a museum can choose three paintings from its storeroom to put on display, where we do not care about the order. In other words, if <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, and <span class="math notranslate nohighlight">\(c\)</span> are paintings, we do not want to distinguish between choosing <span class="math notranslate nohighlight">\(a\)</span> then <span class="math notranslate nohighlight">\(b\)</span> then <span class="math notranslate nohighlight">\(c\)</span> and choosing <span class="math notranslate nohighlight">\(c\)</span> then <span class="math notranslate nohighlight">\(b\)</span> then <span class="math notranslate nohighlight">\(a\)</span>. When we were arranging paintings along all wall, it made sense to consider these two different arrangements, but if we only care about the <em>set</em> of elements we end up with at the end, the order that we choose them does not matter.</p>
<p>The problem is that each set of three paintings will be counted multiple times. In fact, each one will be counted six times: there are <span class="math notranslate nohighlight">\(3! = 6\)</span> permutations of the set <span class="math notranslate nohighlight">\(\{a, b, c\}\)</span>, for example. So to count the number of outcomes we simply need to divide by 6. In other words, the number we want is <span class="math notranslate nohighlight">\(\frac{26!}{3! \cdot 23!}\)</span>.</p>
<p>There is nothing special about the numbers <span class="math notranslate nohighlight">\(26\)</span> and <span class="math notranslate nohighlight">\(3\)</span>. The same formula holds for what we will call <em>unordered selections of</em> <span class="math notranslate nohighlight">\(k\)</span> <em>elements from a set of</em> <span class="math notranslate nohighlight">\(n\)</span> <em>elements</em>, or <span class="math notranslate nohighlight">\(k\)</span>-<em>combinations from an</em> <span class="math notranslate nohighlight">\(n\)</span>-<em>element set</em>. Our goal is once again to describe the situation in precise mathematical terms, at which point we will be able to state the formula as a theorem.</p>
<p>In fact, describing the situation in more mathematical terms is quite easy to do. If <span class="math notranslate nohighlight">\(S\)</span> is a set of <span class="math notranslate nohighlight">\(n\)</span> elements, an unordered selection of <span class="math notranslate nohighlight">\(k\)</span> elements from <span class="math notranslate nohighlight">\(S\)</span> is just a subset of <span class="math notranslate nohighlight">\(S\)</span> that has cardinality <span class="math notranslate nohighlight">\(k\)</span>.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> Let <span class="math notranslate nohighlight">\(S\)</span> be any set with cardinality <span class="math notranslate nohighlight">\(n\)</span>, and let <span class="math notranslate nohighlight">\(k \leq n\)</span>. Then the number of subsets of <span class="math notranslate nohighlight">\(S\)</span> of cardinality <span class="math notranslate nohighlight">\(k\)</span> is <span class="math notranslate nohighlight">\(\frac{n!}{k!(n-k)!}\)</span>.</p>
<p><strong>Proof.</strong> Let <span class="math notranslate nohighlight">\(U\)</span> be the set of unordered selections of <span class="math notranslate nohighlight">\(k\)</span> elements from <span class="math notranslate nohighlight">\(S\)</span>, let <span class="math notranslate nohighlight">\(V\)</span> be the set of permutations of <span class="math notranslate nohighlight">\([k]\)</span>, and let <span class="math notranslate nohighlight">\(W\)</span> be the set of <em>ordered</em> selections of <span class="math notranslate nohighlight">\(k\)</span> elements from <span class="math notranslate nohighlight">\(S\)</span>. There is a bijection between <span class="math notranslate nohighlight">\(U \times V\)</span> and <span class="math notranslate nohighlight">\(W\)</span>, as follows. Suppose we assign to every <span class="math notranslate nohighlight">\(k\)</span>-element subset <span class="math notranslate nohighlight">\(\{ a_0, \ldots, a_{k-1} \}\)</span> of <span class="math notranslate nohighlight">\(S\)</span> some way of listing the elements, as shown. Then given any such set and any permutation <span class="math notranslate nohighlight">\(f\)</span> of <span class="math notranslate nohighlight">\([k]\)</span>, we get an ordered the ordered selection <span class="math notranslate nohighlight">\((a_{f(0)}, a_{f(1)}, \ldots, a_{f(k-1)})\)</span>. Any ordered selection arises from such a subset and a suitable permutation, so the mapping is surjective. And a different set or a different permutation results in a different ordered selection, so the mapping is injective.</p>
<p>By the counting principles, we have</p>
<div class="math notranslate nohighlight">
\[P(n, k) = |W| = |U \times V| = |U| \cdot |V| = |U| \cdot k!,\]</div>
<p>so we have <span class="math notranslate nohighlight">\(|U| = P(n,k) / k! = \frac{n!}{k!(n-k)!}\)</span>.</p>
<p><strong>Example.</strong> Someone is going on vacation and wants to choose three outfits from ten in their closet to pack in their suitcase. How many choices do they have?</p>
<p><strong>Solution.</strong> <span class="math notranslate nohighlight">\(\frac{10!}{3! 7!} = \frac{10 \cdot 9 \cdot 8}{3 \cdot 2 \cdot 1} = 120\)</span>.</p>
<hr class="docutils" />
<p>The number of unordered selections of <span class="math notranslate nohighlight">\(k\)</span> elements from a set of size <span class="math notranslate nohighlight">\(n\)</span>, or, equivalently, the number of <span class="math notranslate nohighlight">\(k\)</span>-combinations from an <span class="math notranslate nohighlight">\(n\)</span>-element set, is typically denoted by <span class="math notranslate nohighlight">\(\binom{n}{k}\)</span>, <span class="math notranslate nohighlight">\(C(n, k)\)</span>, <span class="math notranslate nohighlight">\(C^n_k\)</span>, or something similar. We will use the first notation, because it is most common. Notice that <span class="math notranslate nohighlight">\(\binom{n}0 = 1\)</span> for every <span class="math notranslate nohighlight">\(n\)</span>; this makes sense, because there is exactly one subset of any <span class="math notranslate nohighlight">\(n\)</span>-element set of cardinality <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>Here is one important property of this function.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> For every <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(k \leq n\)</span>, we have <span class="math notranslate nohighlight">\(\binom{n}{k} = \binom{n}{n - k}\)</span>.</p>
<p><strong>Proof.</strong> This is an easy calculation:</p>
<div class="math notranslate nohighlight">
\[\frac{n!}{(n - k)! (n - (n - k))!} = \frac{n!}{(n - k)! k!}.\]</div>
<p>But it is also easy to see from the combinatorial interpretation: choosing <span class="math notranslate nohighlight">\(k\)</span> outfits from <span class="math notranslate nohighlight">\(n\)</span> to take on vacation is the same task as choosing <span class="math notranslate nohighlight">\(n - k\)</span> outfits to leave home.</p>
<hr class="docutils" />
<p>Here is another important property.</p>
<hr class="docutils" />
<p><strong>Theorem.</strong> For every <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(k\)</span>, if <span class="math notranslate nohighlight">\(k + 1 \leq n\)</span>,
then</p>
<div class="math notranslate nohighlight">
\[\binom{n+1}{k+1} = \binom{n}{k+1} + \binom{n}{k}.\]</div>
<p><strong>Proof.</strong> One way to understand this theorem is in terms of the combinatorial interpretation. Suppose you want to choose <span class="math notranslate nohighlight">\(k+1\)</span> outfits out of <span class="math notranslate nohighlight">\(n + 1\)</span>. Set aside one outfit, say, the blue one. Then you have two choices: you can either choose <span class="math notranslate nohighlight">\(k+1\)</span> outfits from the remaining ones, with <span class="math notranslate nohighlight">\(\binom{n}{k+1}\)</span> possibilities; or you can take the blue one, and choose <span class="math notranslate nohighlight">\(k\)</span> outfits from the remaining ones.</p>
<p>The theorem can also be proved by direct calculation. We can express the left-hand side of the equation as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\binom{n+1}{k+1} &amp; = \frac{(n + 1)!}{(k+1)!((n+1)-(k+1))!} \\ &amp; = \frac{(n + 1)!}{(k+1)!(n - k)!}.\end{split}\]</div>
<p>Similarly, we can simplify the right-hand side:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\binom{n}{k+1} + \binom{n}{k} &amp; = \frac{n!}{(k+1)!(n-(k+1))!} + \frac{n!}{k!(n-k)!} \\
&amp; = \frac{n!(n-k)}{(k+1)!(n-k-1)!(n-k)} + \frac{(k+1)n!}{(k+1)k!(n-k)!} \\
&amp; = \frac{n!(n-k)}{(k+1)!(n-k)!} + \frac{(k+1)n!}{(k+1)!(n-k)!} \\
&amp; = \frac{n!(n-k + k + 1)}{(k+1)!(n-k)!} \\
&amp; = \frac{n!(n + 1)}{(k+1)!(n-k)!} \\
&amp; = \frac{(n + 1)!}{(k+1)!(n-k)!}.\end{split}\]</div>
<p>Thus the left-hand side and the right-hand side are equal.</p>
<hr class="docutils" />
<p>For every <span class="math notranslate nohighlight">\(n\)</span>, we know <span class="math notranslate nohighlight">\(\binom{n}{0} = \binom{n}{n} = 1\)</span>. The previous theorem then gives a recipe to compute all the binomial coefficients: once we have determine <span class="math notranslate nohighlight">\(\binom{n}{k}\)</span> for some <span class="math notranslate nohighlight">\(n\)</span> and every <span class="math notranslate nohighlight">\(k \leq n\)</span>, we can determine the values of <span class="math notranslate nohighlight">\(\binom{n+1}{k}\)</span> for every <span class="math notranslate nohighlight">\(k \leq n + 1\)</span> using the recipe above. The results can be displayed graphically in what is known as <em>Pascal&#8217;s triangle</em>:</p>
<img src="_static/combinatorics.1.png"><p>Specifically, if we start counting at <span class="math notranslate nohighlight">\(0\)</span>, the <span class="math notranslate nohighlight">\(k\)</span>th element of the <span class="math notranslate nohighlight">\(n\)</span>th row is equal to <span class="math notranslate nohighlight">\(\binom{n}{k}\)</span>.</p>
<p>There is also a connection between <span class="math notranslate nohighlight">\(\binom{n}{k}\)</span> and the polynomials <span class="math notranslate nohighlight">\((a + b)^n\)</span>, namely, that the <span class="math notranslate nohighlight">\(k\)</span>th coefficient of <span class="math notranslate nohighlight">\((a + b)^n\)</span> is exactly <span class="math notranslate nohighlight">\(\binom{n}{k}\)</span>. For example, we have</p>
<div class="math notranslate nohighlight">
\[(a + b)^4 = a^4 + 4 a^3 b + 6 a^2 b^2 + 4 a b^3 + b^4.\]</div>
<p>For that reason, the values <span class="math notranslate nohighlight">\(\binom{n}{k}\)</span> are often called <em>binomial coefficients</em>, and the statement that</p>
<div class="math notranslate nohighlight">
\[(a + b)^n = \sum_{k \le n} \binom{n}{k} a^{n-k} b^k\]</div>
<p>is known as the <em>binomial theorem</em>.</p>
<p>There are a couple of ways of seeing why this theorem holds. One is to expand the polynomial,</p>
<div class="math notranslate nohighlight">
\[(a + b)^n = (a + b) (a + b) \cdots (a + b)\]</div>
<p>and notice that the coefficient of the term <span class="math notranslate nohighlight">\(a^{n-k} b^k\)</span> is equal to the number of ways of taking the summand <span class="math notranslate nohighlight">\(b\)</span> in exactly <span class="math notranslate nohighlight">\(k\)</span> positions, and <span class="math notranslate nohighlight">\(a\)</span> in the remaining <span class="math notranslate nohighlight">\(n - k\)</span> positions. Another way to prove the result is to use induction on <span class="math notranslate nohighlight">\(n\)</span>, and use the identity <span class="math notranslate nohighlight">\(\binom{n+1}{k+1} = \binom{n}{k+1} + \binom{n}{k}\)</span>. The details are left as an exercise.</p>
<p>Finally, we have considered ordered selections with and without repetitions, and unordered selections without repetitions. What about unordered selections with repetitions? In other words, given a set <span class="math notranslate nohighlight">\(S\)</span> with <span class="math notranslate nohighlight">\(n\)</span> elements, we would like to know how many ways there are of making <span class="math notranslate nohighlight">\(k\)</span> choices, where we can choose elements of <span class="math notranslate nohighlight">\(S\)</span> repeatedly, but we only care about the number of times each element was chosen, and not the order. We have the following:</p>
<hr class="docutils" />
<p>The number of unordered selections of <span class="math notranslate nohighlight">\(k\)</span> elements from an <span class="math notranslate nohighlight">\(n\)</span>-element set, with repetition, is <span class="math notranslate nohighlight">\(\binom{n + k - 1}{k}\)</span>.</p>
<hr class="docutils" />
<p>A proof of this is outlined in the exercises.</p>
</div>
<div class="section" id="the-inclusion-exclusion-principle">
<h2><span class="section-number">20.5. </span>The Inclusion-Exclusion Principle<a class="headerlink" href="#the-inclusion-exclusion-principle" title="Permalink to this headline">&#182;</a></h2>
<p>Let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be any two subsets of some domain, <span class="math notranslate nohighlight">\(U\)</span>. Then <span class="math notranslate nohighlight">\(A = A \setminus B \cup (A \cap B)\)</span>, and the two sets in the union are disjoint, so we have <span class="math notranslate nohighlight">\(|A| = |A \setminus B| + |A \cap B|\)</span>. This means <span class="math notranslate nohighlight">\(|A \setminus B| = |A| - |A \cap B|\)</span>. Intuitively, this makes sense: we can count the elements of <span class="math notranslate nohighlight">\(A \setminus B\)</span> by counting the elements in <span class="math notranslate nohighlight">\(A\)</span>, and then subtracting the number of elements that are in both <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Similarly, we have <span class="math notranslate nohighlight">\(A \cup B = A \cup (B \setminus A)\)</span>, and the two sets on the right-hand side of this equation are disjoint, so we
have</p>
<div class="math notranslate nohighlight">
\[|A \cup B| = |A| + |B \setminus A| = |A| + |B| - |A \cap B|.\]</div>
<p>If we draw a Venn diagram, this makes sense: to count the elements in <span class="math notranslate nohighlight">\(A \cup B\)</span>, we can add the number of elements in <span class="math notranslate nohighlight">\(A\)</span> to the number of elements in <span class="math notranslate nohighlight">\(B\)</span>, but then we have to subtract the number of elements of both.</p>
<p>What happen when there are three sets? To compute <span class="math notranslate nohighlight">\(|A \cup B \cup C|\)</span>, we can start by adding the number of elements in each, and then subtracting the number of elements of <span class="math notranslate nohighlight">\(| A \cap B |\)</span>, <span class="math notranslate nohighlight">\(|A \cap C|\)</span>, and <span class="math notranslate nohighlight">\(|B \cap C|\)</span>, each of which have been double-counted. But thinking about the Venn diagram should help us realize that then we have over-corrected: each element of <span class="math notranslate nohighlight">\(A \cap B \cap C\)</span> was counted three times in the original sum, and the subtracted three times. So we need to add them back in:</p>
<div class="math notranslate nohighlight">
\[| A \cup B \cup C | = | A | + | B | + | C | - | A \cap B | - | A \cap C | - | B \cap C | + | A \cap B \cap C |.\]</div>
<p>This generalizes to any number of sets. To state the general result, suppose the sets are numbered <span class="math notranslate nohighlight">\(A_0, \ldots, A_{n-1}\)</span>. For each nonempty subset <span class="math notranslate nohighlight">\(I\)</span> of <span class="math notranslate nohighlight">\(\{0, \ldots, n-1 \}\)</span>, consider <span class="math notranslate nohighlight">\(\bigcap_{i \in I} A_i\)</span>. If <span class="math notranslate nohighlight">\(|I|\)</span> is odd (that is, equal to 1, 3, 5, &#8230;) we want to add the cardinality of the intersection; if it is even we want to subtract it. This recipe is expressed compactly by the following formula:</p>
<div class="math notranslate nohighlight">
\[\left| \bigcup_{i &lt; n} A_i \right| = \sum_{\emptyset \ne I \subseteq [n]} (-1)^{|I|+1} \left| \bigcap_{i \in I} A_i \right| .\]</div>
<p>You are invited to try proving this as an exercise, if you are ambitious. The following example illustrates its use:</p>
<hr class="docutils" />
<p><strong>Example.</strong> Among a group of college Freshmen, 30 are taking Logic, 25 are taking History, and 20 are taking French. Moreover, 11 are taking Logic and History, 10 are taking Logic and French, 7 are taking History and French, and 3 are taking all three. How many students are taking at least one of the three classes?</p>
<p><strong>Solution.</strong> Letting <span class="math notranslate nohighlight">\(L\)</span>, <span class="math notranslate nohighlight">\(H\)</span>, and <span class="math notranslate nohighlight">\(F\)</span> denote the sets of students taking Logic, History, and French, respectively, we have</p>
<div class="math notranslate nohighlight">
\[| L \cup H \cup F | = 30 + 25 + 20 - 11 - 10 - 7 + 3 = 50.\]</div>
</div>
<hr class="docutils" />
<div class="section" id="exercises">
<h2><span class="section-number">20.6. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h2>
<ol class="arabic">
<li><p>Suppose that, at a party, every two people either know each other or don&#8217;t. In other words, &#8220;<span class="math notranslate nohighlight">\(x\)</span> knows <span class="math notranslate nohighlight">\(y\)</span>&#8221; is symmetric. Also, let us ignore the complex question of whether we always know ourselves by restricting attention to the relation between distinct people; in other words, for this problem, take &#8220;<span class="math notranslate nohighlight">\(x\)</span> knows <span class="math notranslate nohighlight">\(y\)</span>&#8221; to be irreflexive as well.</p>
<p>Use the pigeonhole principle (and an additional insight) to show that there must be two people who know exactly the same number of people.</p>
</li>
<li><p>Show that in any set of <span class="math notranslate nohighlight">\(n + 1\)</span> integers, two of them are equivalent modulo <span class="math notranslate nohighlight">\(n\)</span>.</p></li>
<li><p>Spell out in detail a proof of the second counting principle in <a class="reference internal" href="#counting-principles"><span class="std std-numref">Section 20.2</span></a>.</p></li>
<li><p>An ice cream parlor has 31 flavors of ice cream.</p>
<ol class="loweralpha simple">
<li><p>Determine how many three-flavor ice-cream cones are possible, if we care about the order and repetitions are allowed. (So choosing chocolate-chocolate-vanilla scoops, from bottom to top, is different from choosing chocolate-vanilla-chocolate.)</p></li>
<li><p>Determine how many three flavor ice-cream cones are possible, if we care about the order, but repetitions are not allowed.</p></li>
<li><p>Determine how many three flavor ice-cream cones are possible, if we don&#8217;t care about the order, but repetitions are not allowed.</p></li>
</ol>
</li>
<li><p>A club of 10 people has to elect a president, vice president, and secretary. How many possibilities are there:</p>
<ol class="loweralpha simple">
<li><p>if no person can hold more than one office?</p></li>
<li><p>if anyone can hold any number of those offices?</p></li>
<li><p>if anyone can hold up to two offices?</p></li>
<li><p>if the president cannot hold another office, but the vice president and secretary may or may not be the same person?</p></li>
</ol>
</li>
<li><p>How many 7 digit phone numbers are there, if any 7 digits can be used? How many are there if the first digit cannot be 0?</p></li>
<li><p>In a class of 20 kindergarten students, two are twins. How many ways are there of lining up the students, so that the twins are standing together?</p></li>
<li><p>A woman has 8 murder mysteries sitting on her shelf, and wants to take three of them on a vacation. How many ways can she do this?</p></li>
<li><p>In poker, a &#8220;full house&#8221; is a hand with three of one rank and two of another (for example, three kings and two fives). Determine the number of full houses that can be formed from an ordinary deck of 52 cards.</p></li>
<li><p>We saw in <a class="reference internal" href="#combinations-and-binomial-coefficients"><span class="std std-numref">Section 20.4</span></a> that</p>
<div class="math notranslate nohighlight">
\[\binom{n+1}{k+1} = \binom{n}{k+1} + \binom{n}{k}.\]</div>
<p>Replacing <span class="math notranslate nohighlight">\(k + 1\)</span> by <span class="math notranslate nohighlight">\(k\)</span>, whenever <span class="math notranslate nohighlight">\(1 \leq k \leq n\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\binom{n+1}{k} = \binom{n}{k} + \binom{n}{k-1}.\]</div>
<p>Use this to show, by induction on <span class="math notranslate nohighlight">\(n\)</span>, that for every <span class="math notranslate nohighlight">\(k \leq n\)</span>, that if <span class="math notranslate nohighlight">\(S\)</span> is any set of <span class="math notranslate nohighlight">\(n\)</span> elements, <span class="math notranslate nohighlight">\(\binom{n}{k}\)</span> is the number of subsets of <span class="math notranslate nohighlight">\(S\)</span> with <span class="math notranslate nohighlight">\(k\)</span> elements.</p>
</li>
<li><p>How many distinct arrangements are there of the letters in the word MISSISSIPPI?</p>
<p>(Hint: this is tricky. First, suppose all the S&#8217;s, I&#8217;s, and P&#8217;s were painted different colors. Then determine how many distinct arrangements of the letters there would be. In the absence of distinguishing colors, determine how many times each configuration appeared in the first count, and divide by that number.)</p>
</li>
<li><p>Prove the inclusion-exclusion principle.</p></li>
<li><p>Use the inclusion-exclusion principle to determine the number of integers less than 100 that are divisible by 2, 3, or 5.</p></li>
<li><p>Show that the number of <em>unordered</em> selections of <span class="math notranslate nohighlight">\(k\)</span> elements from an <span class="math notranslate nohighlight">\(n\)</span>-element set is <span class="math notranslate nohighlight">\(\binom{n + k - 1}{k}\)</span>.</p>
<p>Hint: consider <span class="math notranslate nohighlight">\([n]\)</span>. We need to choose some number <span class="math notranslate nohighlight">\(i_0\)</span> of 0&#8217;s, some number <span class="math notranslate nohighlight">\(i_1\)</span> of 1&#8217;s, and so on, so that <span class="math notranslate nohighlight">\(i_0 + i_1 + \ldots + i_{n-1} = k\)</span>. Suppose we assign to each such tuple a the following binary sequence: we write down <span class="math notranslate nohighlight">\(i_0\)</span> 0&#8217;s, then a 1, then <span class="math notranslate nohighlight">\(i_1\)</span> 0&#8217;s, then a 1, then <span class="math notranslate nohighlight">\(i_2\)</span> 0&#8217;s, and so on. The result is a binary sequence of length <span class="math notranslate nohighlight">\(n + k - 1\)</span> with exactly <span class="math notranslate nohighlight">\(k\)</span> 1&#8217;s, and such binary sequence arises from a unique tuple in this way.</p>
</li>
</ol>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Logic and Proof</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_propositional_logic.html">3. Natural Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">4. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_reasoning.html">5. Classical Reasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_propositional_logic.html">6. Semantics of Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">7. First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_first_order_logic.html">8. Natural Deduction for First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">9. First Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_first_order_logic.html">10. Semantics of First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets.html">11. Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_in_lean.html">12. Sets in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations.html">13. Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations_in_lean.html">14. Relations in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">15. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions_in_lean.html">16. Functions in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction.html">17. The Natural Numbers and Induction</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction_in_lean.html">18. The Natural Numbers and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory.html">19. Elementary Number Theory</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">20. Combinatorics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#finite-sets-and-cardinality">20.1. Finite Sets and Cardinality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#counting-principles">20.2. Counting Principles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ordered-selections">20.3. Ordered Selections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#combinations-and-binomial-coefficients">20.4. Combinations and Binomial Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-inclusion-exclusion-principle">20.5. The Inclusion-Exclusion Principle</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">20.6. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="the_real_numbers.html">21. The Real Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_infinite.html">22. The Infinite</a></li>
<li class="toctree-l1"><a class="reference internal" href="axiomatic_foundations.html">23. Axiomatic Foundations</a></li>
<li class="toctree-l1"><a class="reference internal" href="nd_quickref.html">24. Appendix: Natural Deduction Rules</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="logic_and_proof.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/combinatorics.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>