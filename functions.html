
<!DOCTYPE html>

<html>
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>15. Functions &#8212; Logic and Proof 3.18.4 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="16. Functions in Lean" href="functions_in_lean.html" />
    <link rel="prev" title="14. Relations in Lean" href="relations_in_lean.html" />
<!-- <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=Average" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> -->

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="functions">
<span id="id1"></span><h1><span class="section-number">15. </span>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">&#182;</a></h1>
<p>In the late nineteenth century, developments in a number of branches of mathematics pushed towards a uniform treatment of sets, functions, and relations. We have already considered sets and relations. In this chapter, we consider functions and their properties.</p>
<p>A function, <span class="math notranslate nohighlight">\(f\)</span>, is ordinary understood as a mapping from a domain <span class="math notranslate nohighlight">\(X\)</span> to another domain <span class="math notranslate nohighlight">\(Y\)</span>. In set-theoretic foundations, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are arbitrary sets. We have seen that in a type-based system like Lean, it is natural to distinguish between types and subsets of a type. In other words, we can consider a type <code class="docutils literal notranslate"><span class="pre">X</span></code> of elements, and a set <code class="docutils literal notranslate"><span class="pre">A</span></code> of elements of that type. Thus, in the type-theoretic formulation, it is natural to consider functions between types <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code>, and consider their behavior with respect to subsets of <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code>.</p>
<p>In everyday mathematics, however, set-theoretic language is common, and most mathematicians think of a function as a map between sets. When discussing functions from a mathematical standpoint, therefore, we will also adopt this language, and later switch to the type-theoretic representation when we talk about formalization in Lean.</p>
<div class="section" id="the-function-concept">
<h2><span class="section-number">15.1. </span>The Function Concept<a class="headerlink" href="#the-function-concept" title="Permalink to this headline">&#182;</a></h2>
<p>If <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are any sets, we write <span class="math notranslate nohighlight">\(f : X \to Y\)</span> to express the fact that <span class="math notranslate nohighlight">\(f\)</span> is a function from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>. This means that <span class="math notranslate nohighlight">\(f\)</span> assigns a value <span class="math notranslate nohighlight">\(f(x)\)</span> in <span class="math notranslate nohighlight">\(Y\)</span> to every element <span class="math notranslate nohighlight">\(x\)</span> of <span class="math notranslate nohighlight">\(X\)</span>. The set <span class="math notranslate nohighlight">\(X\)</span> is called the <em>domain</em> of <span class="math notranslate nohighlight">\(f\)</span>, and the set <span class="math notranslate nohighlight">\(Y\)</span> is called the <em>codomain</em>. (Some authors use the word &#8220;range&#8221; for the codomain, but today it is more common to use the word &#8220;range&#8221; for what we call the <em>image</em> of <span class="math notranslate nohighlight">\(A\)</span> below. We will avoid the ambiguity by avoiding the word range altogether.)</p>
<p>The simplest way to define a function is to give its value at every <span class="math notranslate nohighlight">\(x\)</span> with an explicit expression. For example, we can write any of the following:</p>
<ul>
<li><p>Let <span class="math notranslate nohighlight">\(f : \mathbb{N} \to \mathbb{N}\)</span> be the function defined by <span class="math notranslate nohighlight">\(f(n) = n + 1\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(g : \mathbb{R} \to \mathbb{R}\)</span> be the function defined by <span class="math notranslate nohighlight">\(g(x) = x^2\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(h : \mathbb{N} \to \mathbb{N}\)</span> be the function defined by <span class="math notranslate nohighlight">\(h(n) = n^2\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(k : \mathbb{N} \to \{0, 1\}\)</span> be the function defined by</p>
<div class="math notranslate nohighlight">
\[\begin{split}k(n) =
  \left\{\begin{array}{ll}
    0 &amp; \mbox{if $n$ is even} \\
    1 &amp; \mbox{if $n$ is odd.}
  \end{array}\right.\end{split}\]</div>
</li>
</ul>
<p>The ability to define functions using an explicit expression raises the foundational question as to what counts as legitimate &#8220;expression.&#8221; For the moment, let us set that question aside, and simply note that modern mathematics is comfortable with all kinds of exotic definitions. For example, we can define a function <span class="math notranslate nohighlight">\(f : \mathbb{R} \to \{0, 1\}\)</span> by</p>
<div class="math notranslate nohighlight">
\[\begin{split}f(x) =
  \left\{\begin{array}{ll}
    0 &amp; \mbox{if $x$ is rational} \\
    1 &amp; \mbox{if $x$ is irrational.}
  \end{array}\right.\end{split}\]</div>
<p>This is at odds with a view of functions as objects that are computable in some sense. It is not at all clear what it means to be presented with a real number as input, let alone whether it is possible to determine, algorithmically, whether such a number is rational or not. We will return to such issues in a later chapter.</p>
<p>Notice that the choice of the variables <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(n\)</span> in the definitions above are arbitrary. They are bound variables in that the functions being defined do not depend on <span class="math notranslate nohighlight">\(x\)</span> or <span class="math notranslate nohighlight">\(n\)</span>. The values remain the same under renaming, just as the truth values of &#8220;for every <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(P(x)\)</span>&#8221; and &#8220;for every <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(P(y)\)</span>&#8221; are the same. Given an expression <span class="math notranslate nohighlight">\(e(x)\)</span> that depends on the variable <span class="math notranslate nohighlight">\(x\)</span>, logicians often use the notation <span class="math notranslate nohighlight">\(\lambda x \; e(x)\)</span> to denote the function that maps <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(e(x)\)</span>. This is called &#8220;lambda notation,&#8221; for the obvious reason, and it is often quite handy. Instead of saying &#8220;let <span class="math notranslate nohighlight">\(f\)</span> be the function defined by <span class="math notranslate nohighlight">\(f(x) = x+1\)</span>,&#8221; we can say &#8220;let <span class="math notranslate nohighlight">\(f = \lambda \; x (x + 1)\)</span>.&#8221; This is <em>not</em> common mathematical notation, and it is best to avoid it unless you are talking to logicians or computer scientists. We will see, however, that lambda notation is built in to Lean.</p>
<p>For any set <span class="math notranslate nohighlight">\(X\)</span>, we can define a function <span class="math notranslate nohighlight">\(i_X(x)\)</span> by the equation <span class="math notranslate nohighlight">\(i_X(x) = x\)</span>. This function is called the <em>identity function</em>. More interestingly, let <span class="math notranslate nohighlight">\(f : X \to Y\)</span> and <span class="math notranslate nohighlight">\(g : Y \to Z\)</span>. We can define a new function <span class="math notranslate nohighlight">\(k : X \to Z\)</span> by <span class="math notranslate nohighlight">\(k(x) = g(f(x))\)</span>. The function <span class="math notranslate nohighlight">\(k\)</span> is called <em>the composition of</em> <span class="math notranslate nohighlight">\(f\)</span> <em>and</em> <span class="math notranslate nohighlight">\(g\)</span> or <span class="math notranslate nohighlight">\(f\)</span> <em>composed with</em> <span class="math notranslate nohighlight">\(g\)</span> and it is written <span class="math notranslate nohighlight">\(g \circ f\)</span>. The order is somewhat confusing; you just have to keep in mind that to evaluate the expression <span class="math notranslate nohighlight">\(g(f(x))\)</span> you first evaluate <span class="math notranslate nohighlight">\(f\)</span> on input <span class="math notranslate nohighlight">\(x\)</span>, and then evaluate <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>We think of two functions <span class="math notranslate nohighlight">\(f, g : X \to Y\)</span> as being equal, or the same function, when for they have the same values on every input; in other words, for every <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(f(x) = g(x)\)</span>. For example, if <span class="math notranslate nohighlight">\(f, g : \mathbb{R} \to \mathbb{R}\)</span> are defined by <span class="math notranslate nohighlight">\(f(x) = x + 1\)</span> and <span class="math notranslate nohighlight">\(g(x) = 1 + x\)</span>, then <span class="math notranslate nohighlight">\(f = g\)</span>. Notice that the statement that two functions are equal is a universal statement (that is, for the form &#8220;for every <span class="math notranslate nohighlight">\(x\)</span>, &#8230;&#8221;).</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> For every <span class="math notranslate nohighlight">\(f : X \to Y\)</span>, <span class="math notranslate nohighlight">\(f \circ i_X = f\)</span> and <span class="math notranslate nohighlight">\(i_Y \circ f = f\)</span>.</p>
<p><strong>Proof.</strong> Let <span class="math notranslate nohighlight">\(x\)</span> be any element of <span class="math notranslate nohighlight">\(X\)</span>. Then <span class="math notranslate nohighlight">\((f \circ i_X)(x) = f(i_X(x)) = f(x)\)</span>, and <span class="math notranslate nohighlight">\((i_Y \circ f)(x) = i_Y(f(x)) = x\)</span>.</p>
<hr class="docutils" />
<p>Suppose <span class="math notranslate nohighlight">\(f : X \to Y\)</span> and <span class="math notranslate nohighlight">\(g : Y \to X\)</span> satisfy <span class="math notranslate nohighlight">\(g \circ f = i_X\)</span>. Remember that this means that <span class="math notranslate nohighlight">\(g(f(x)) = x\)</span> for every <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(X\)</span>. In that case, <span class="math notranslate nohighlight">\(g\)</span> is said to be a <em>left inverse</em> to <span class="math notranslate nohighlight">\(f\)</span>, and <span class="math notranslate nohighlight">\(f\)</span> is said to be a <em>right inverse</em> to <span class="math notranslate nohighlight">\(g\)</span>. Here are some examples:</p>
<ul class="simple">
<li><p>Define <span class="math notranslate nohighlight">\(f, g : \mathbb{R} \to \mathbb{R}\)</span> by <span class="math notranslate nohighlight">\(f(x) = x + 1\)</span> and <span class="math notranslate nohighlight">\(g(x) = x - 1\)</span>. Then <span class="math notranslate nohighlight">\(g\)</span> is both a left and a right inverse to <span class="math notranslate nohighlight">\(f\)</span>, and vice-versa.</p></li>
<li><p>Write <span class="math notranslate nohighlight">\(\mathbb{R}^{\geq 0}\)</span> to denote the nonnegative reals. Define <span class="math notranslate nohighlight">\(f : \mathbb{R} \to \mathbb{R}^{\geq 0}\)</span> by <span class="math notranslate nohighlight">\(f(x) = x^2\)</span>, and define <span class="math notranslate nohighlight">\(g : \mathbb{R}^{\geq 0} \to \mathbb{R}\)</span> by <span class="math notranslate nohighlight">\(g(x) = \sqrt x\)</span>. Then <span class="math notranslate nohighlight">\(f(g(x)) = (\sqrt x)^2 = x\)</span> for every <span class="math notranslate nohighlight">\(x\)</span> in the domain of <span class="math notranslate nohighlight">\(g\)</span>, so <span class="math notranslate nohighlight">\(f\)</span> is a left inverse to <span class="math notranslate nohighlight">\(g\)</span>, and <span class="math notranslate nohighlight">\(g\)</span> is a right inverse to <span class="math notranslate nohighlight">\(f\)</span>. On the other hand, <span class="math notranslate nohighlight">\(g(f(x)) = \sqrt{x^2} = | x |\)</span>, which is not the same as <span class="math notranslate nohighlight">\(x\)</span> when <span class="math notranslate nohighlight">\(x\)</span> is negative. So <span class="math notranslate nohighlight">\(g\)</span> is not a left inverse to <span class="math notranslate nohighlight">\(f\)</span>, and <span class="math notranslate nohighlight">\(f\)</span> is not a right inverse to <span class="math notranslate nohighlight">\(g\)</span>.</p></li>
</ul>
<p>The following fact is not at all obvious, even though the proof is short:</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math notranslate nohighlight">\(f : X \to Y\)</span> has a left inverse, <span class="math notranslate nohighlight">\(h\)</span>, and a right inverse, <span class="math notranslate nohighlight">\(k\)</span>. Then <span class="math notranslate nohighlight">\(h = k\)</span>.</p>
<p><strong>Proof.</strong> Let <span class="math notranslate nohighlight">\(y\)</span> be any element in <span class="math notranslate nohighlight">\(Y\)</span>. The idea is to compute <span class="math notranslate nohighlight">\(h(f(k(y))\)</span> in two different ways. Since <span class="math notranslate nohighlight">\(h\)</span> is a left inverse to <span class="math notranslate nohighlight">\(f\)</span>, we have <span class="math notranslate nohighlight">\(h(f(k(y))) = k(y)\)</span>. On the other hand, since <span class="math notranslate nohighlight">\(k\)</span> is a right inverse to <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(f(k(y)) = y\)</span>, and so <span class="math notranslate nohighlight">\(h(f(k(y)) = h(y)\)</span>. So <span class="math notranslate nohighlight">\(k(y) = h(y)\)</span>.</p>
<hr class="docutils" />
<p>If <span class="math notranslate nohighlight">\(g\)</span> is both a right and left inverse to <span class="math notranslate nohighlight">\(f\)</span>, we say that <span class="math notranslate nohighlight">\(g\)</span> is simply the inverse of <span class="math notranslate nohighlight">\(f\)</span>. A function <span class="math notranslate nohighlight">\(f\)</span> may have more than one left or right inverse (we leave it to you to cook up examples), but it can have at most one inverse.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math notranslate nohighlight">\(g_1, g_2 : Y \to X\)</span> are both inverses to <span class="math notranslate nohighlight">\(f\)</span>. Then <span class="math notranslate nohighlight">\(g_1 = g_2\)</span>.</p>
<p><strong>Proof.</strong> This follows from the previous proposition, since (say) <span class="math notranslate nohighlight">\(g_1\)</span> is a left inverse to <span class="math notranslate nohighlight">\(f\)</span>, and <span class="math notranslate nohighlight">\(g_2\)</span> is a right inverse.</p>
<hr class="docutils" />
<p>When <span class="math notranslate nohighlight">\(f\)</span> has an inverse, <span class="math notranslate nohighlight">\(g\)</span>, this justifies calling <span class="math notranslate nohighlight">\(g\)</span> <em>the</em> inverse to <span class="math notranslate nohighlight">\(f\)</span>, and writing <span class="math notranslate nohighlight">\(f^{-1}\)</span> to denote <span class="math notranslate nohighlight">\(g\)</span>. Notice that if <span class="math notranslate nohighlight">\(f^{-1}\)</span> is an inverse to <span class="math notranslate nohighlight">\(f\)</span>, then <span class="math notranslate nohighlight">\(f\)</span> is an inverse to <span class="math notranslate nohighlight">\(f^{-1}\)</span>. So if <span class="math notranslate nohighlight">\(f\)</span> has an inverse, then so does <span class="math notranslate nohighlight">\(f^{-1}\)</span>, and <span class="math notranslate nohighlight">\((f^{-1})^{-1} = f\)</span>. For any set <span class="math notranslate nohighlight">\(A\)</span>, clearly we have <span class="math notranslate nohighlight">\(i_X^{-1} = i_X\)</span>.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math notranslate nohighlight">\(f : X \to Y\)</span> and <span class="math notranslate nohighlight">\(g : Y \to Z\)</span>. If <span class="math notranslate nohighlight">\(h : Y \to X\)</span> is a left inverse to <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(k : Z \to Y\)</span> is a left inverse to <span class="math notranslate nohighlight">\(g\)</span>, then <span class="math notranslate nohighlight">\(h \circ k\)</span> is a left inverse to <span class="math notranslate nohighlight">\(g \circ f\)</span>.</p>
<p><strong>Proof.</strong> For every <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(X\)</span>,</p>
<div class="math notranslate nohighlight">
\[(h \circ k) \circ (g \circ f) (x) = h(k(g(f(x)))) = h(f(x)) = x.\]</div>
<p><strong>Corollary.</strong> The previous proposition holds with &#8220;left&#8221; replaced by &#8220;right.&#8221;</p>
<p><strong>Proof.</strong> Switch the role of <span class="math notranslate nohighlight">\(f\)</span> with <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(g\)</span> with <span class="math notranslate nohighlight">\(k\)</span> in the previous proposition.</p>
<p><strong>Corollary.</strong> If <span class="math notranslate nohighlight">\(f : X \to Y\)</span> and <span class="math notranslate nohighlight">\(g : Y \to Z\)</span> both have inverses, then <span class="math notranslate nohighlight">\((f \circ g)^{-1} = g^{-1} \circ f^{-1}\)</span>.</p>
<hr class="docutils" />
</div>
<div class="section" id="injective-surjective-and-bijective-functions">
<span id="id2"></span><h2><span class="section-number">15.2. </span>Injective, Surjective, and Bijective Functions<a class="headerlink" href="#injective-surjective-and-bijective-functions" title="Permalink to this headline">&#182;</a></h2>
<p>A function <span class="math notranslate nohighlight">\(f : X \to Y\)</span> is said to be <em>injective</em>, or an <em>injection</em>, or <em>one-one</em>, if given any <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(x_2\)</span> in <span class="math notranslate nohighlight">\(A\)</span>, if <span class="math notranslate nohighlight">\(f(x_1) = f(x_2)\)</span>, then <span class="math notranslate nohighlight">\(x_1 = x_2\)</span>. Notice that the conclusion is equivalent to its contrapositive: if <span class="math notranslate nohighlight">\(x_1 \neq x_2\)</span>, then <span class="math notranslate nohighlight">\(f(x_1) \neq f(x_2)\)</span>. So <span class="math notranslate nohighlight">\(f\)</span> is injective if it maps distinct element of <span class="math notranslate nohighlight">\(X\)</span> to distinct elements of <span class="math notranslate nohighlight">\(Y\)</span>.</p>
<p>A function <span class="math notranslate nohighlight">\(f : X \to Y\)</span> is said to be <em>surjective</em>, or a <em>surjection</em>, or <em>onto</em>, if for every element <span class="math notranslate nohighlight">\(y\)</span> of <span class="math notranslate nohighlight">\(Y\)</span>, there is an <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(X\)</span> such that <span class="math notranslate nohighlight">\(f(x) = y\)</span>. In other words, <span class="math notranslate nohighlight">\(f\)</span> is surjective if every element in the codomain is the value of <span class="math notranslate nohighlight">\(f\)</span> at some element in the domain.</p>
<p>A function <span class="math notranslate nohighlight">\(f : X \to Y\)</span> is said to be <em>bijective</em>, or a <em>bijection</em>, or a <em>one-to-one correspondence</em>, if it is both injective and surjective. Intuitively, if there is a bijection between <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>, then <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> have the same size, since <span class="math notranslate nohighlight">\(f\)</span> makes each element of <span class="math notranslate nohighlight">\(X\)</span> correspond to exactly one element of <span class="math notranslate nohighlight">\(Y\)</span> and vice-versa. For example, it makes sense to interpret the statement that there were four Beatles as the statement that there is a bijection between the set <span class="math notranslate nohighlight">\(\{1, 2, 3, 4\}\)</span> and the set <span class="math notranslate nohighlight">\(\{ \text{John, Paul, George, Ringo} \}\)</span>. If we claimed that there were <em>five</em> Beatles, as evidenced by the function <span class="math notranslate nohighlight">\(f\)</span> which assigns 1 to John, 2 to Paul, 3 to George, 4 to Ringo, and 5 to John, you should object that we double-counted John&#8212;that is, <span class="math notranslate nohighlight">\(f\)</span> is not injective. If we claimed there were only three Beatles, as evidenced by the function <span class="math notranslate nohighlight">\(f\)</span> which assigns 1 to John, 2 to Paul, and 3 to George, you should object that we left out poor Ringo&#8212;that is, <span class="math notranslate nohighlight">\(f\)</span> is not surjective.</p>
<p>The next two propositions show that these notions can be cast in terms of the existence of inverses.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Let <span class="math notranslate nohighlight">\(f : X \to Y\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> has a left inverse, then <span class="math notranslate nohighlight">\(f\)</span> is injective.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> has a right inverse, then <span class="math notranslate nohighlight">\(f\)</span> is surjective.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> has an inverse, then it is <span class="math notranslate nohighlight">\(f\)</span> bijective.</p></li>
</ul>
<p><strong>Proof.</strong> For the first claim, suppose <span class="math notranslate nohighlight">\(f\)</span> has a left inverse <span class="math notranslate nohighlight">\(g\)</span>, and suppose <span class="math notranslate nohighlight">\(f(x_1) = f(x_2)\)</span>. Then <span class="math notranslate nohighlight">\(g(f(x_1)) = g(f(x_2))\)</span>, and so <span class="math notranslate nohighlight">\(x_1 = x_2\)</span>.</p>
<p>For the second claim, suppose <span class="math notranslate nohighlight">\(f\)</span> has a right inverse <span class="math notranslate nohighlight">\(h\)</span>. Let <span class="math notranslate nohighlight">\(y\)</span> be any element of <span class="math notranslate nohighlight">\(Y\)</span>, and let <span class="math notranslate nohighlight">\(x = g(y)\)</span>. Then <span class="math notranslate nohighlight">\(f(x) = f(g(y)) = y\)</span>.</p>
<p>The third claim follows from the first two.</p>
<hr class="docutils" />
<p>The following proposition is more interesting, because it requires us to define new functions, given hypotheses on <span class="math notranslate nohighlight">\(f\)</span>.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Let <span class="math notranslate nohighlight">\(f : X \to Y\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(X\)</span> is nonempty and <span class="math notranslate nohighlight">\(f\)</span> is injective, then <span class="math notranslate nohighlight">\(f\)</span> has a left inverse.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> is surjective, then <span class="math notranslate nohighlight">\(f\)</span> has a right inverse.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> if bijective, then it has an inverse.</p></li>
</ul>
<p><strong>Proof.</strong> For the first claim, let <span class="math notranslate nohighlight">\(\hat x\)</span> be any element of <span class="math notranslate nohighlight">\(X\)</span>, and suppose <span class="math notranslate nohighlight">\(f\)</span> is injective. Define <span class="math notranslate nohighlight">\(g : Y \to X\)</span> by setting <span class="math notranslate nohighlight">\(g(y)\)</span> equal to any <span class="math notranslate nohighlight">\(x\)</span> such that <span class="math notranslate nohighlight">\(f(x) = y\)</span>, if there is one, and <span class="math notranslate nohighlight">\(\hat x\)</span> otherwise. Now, suppose <span class="math notranslate nohighlight">\(g(f(x)) = x'\)</span>. By the definition of <span class="math notranslate nohighlight">\(g\)</span>, <span class="math notranslate nohighlight">\(x'\)</span> has to have the property that <span class="math notranslate nohighlight">\(f(x) = f(x')\)</span>. Since <span class="math notranslate nohighlight">\(f\)</span> is injective, <span class="math notranslate nohighlight">\(x = x'\)</span>, so <span class="math notranslate nohighlight">\(g(f(x)) = x\)</span>.</p>
<p>For the second claim, because <span class="math notranslate nohighlight">\(f\)</span> is surjective, we know that for every <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(Y\)</span> there is any <span class="math notranslate nohighlight">\(x\)</span> such that <span class="math notranslate nohighlight">\(f(x) = y\)</span>. Define <span class="math notranslate nohighlight">\(h : B \to A\)</span> by again setting <span class="math notranslate nohighlight">\(h(y)\)</span> equal to any such <span class="math notranslate nohighlight">\(x\)</span>. (In contrast to the previous paragraph, here we know that such an <span class="math notranslate nohighlight">\(x\)</span> exists, but it might not be unique.) Then, by the definition of <span class="math notranslate nohighlight">\(h\)</span>, we have <span class="math notranslate nohighlight">\(f(h(y)) = y\)</span>.</p>
<hr class="docutils" />
<p>Notice that the definition of <span class="math notranslate nohighlight">\(g\)</span> in the first part of the proof requires the function to &#8220;decide&#8221; whether there is an <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(X\)</span> such that <span class="math notranslate nohighlight">\(f(x) = y\)</span>. There is nothing mathematically dubious about this definition, but in many situations, this cannot be done <em>algorithmically</em>; in other words, <span class="math notranslate nohighlight">\(g\)</span> might not be computable from the data. More interestingly, the definition of <span class="math notranslate nohighlight">\(h\)</span> in the second part of the proof requires the function to &#8220;choose&#8221; a suitable value of <span class="math notranslate nohighlight">\(x\)</span> from among potentially many candidates. We will see in <a class="reference internal" href="axiomatic_foundations.html#the-remaining-axioms"><span class="std std-numref">Section 23.3</span></a> that this is a version of the <em>axiom of choice</em>. In the early twentieth century, the use of the axiom of choice in mathematics was hotly debated, but today it is commonplace.</p>
<p>Using these equivalences and the results in the previous section, we can prove the following:</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Let <span class="math notranslate nohighlight">\(f : X \to B\)</span> and <span class="math notranslate nohighlight">\(g : Y \to Z\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are injective, then so is <span class="math notranslate nohighlight">\(g \circ f\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are surjective, then so is <span class="math notranslate nohighlight">\(g \circ f\)</span>.</p></li>
</ul>
<p><strong>Proof.</strong> If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are injective, then they have left inverses <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(k\)</span>, respectively, in which case <span class="math notranslate nohighlight">\(h \circ k\)</span> is a left inverse to <span class="math notranslate nohighlight">\(g \circ f\)</span>. The second statement is proved similarly.</p>
<hr class="docutils" />
<p>We can prove these two statements, however, without mentioning inverses at all. We leave that to you as an exercise.</p>
<p>Notice that the expression <span class="math notranslate nohighlight">\(f(n) = 2 n\)</span> can be used to define infinitely many functions with domain <span class="math notranslate nohighlight">\(\mathbb{N}\)</span>, such as:</p>
<ul class="simple">
<li><p>a function <span class="math notranslate nohighlight">\(f : \mathbb{N} \to \mathbb{N}\)</span></p></li>
<li><p>a function <span class="math notranslate nohighlight">\(f : \mathbb{N} \to \mathbb{R}\)</span></p></li>
<li><p>a function <span class="math notranslate nohighlight">\(f: \mathbb{N} \to \{ n \mid n \text{ is even} \}\)</span></p></li>
</ul>
<p>Only the third one is surjective. Thus a specification of the function&#8217;s codomain as well as the domain is essential to making sense of whether a function is surjective.</p>
</div>
<div class="section" id="functions-and-subsets-of-the-domain">
<h2><span class="section-number">15.3. </span>Functions and Subsets of the Domain<a class="headerlink" href="#functions-and-subsets-of-the-domain" title="Permalink to this headline">&#182;</a></h2>
<p>Suppose <span class="math notranslate nohighlight">\(f\)</span> is a function from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>. We may wish to reason about the behavior of <span class="math notranslate nohighlight">\(f\)</span> on some subset <span class="math notranslate nohighlight">\(A\)</span> of <span class="math notranslate nohighlight">\(X\)</span>. For example, we can say that <span class="math notranslate nohighlight">\(f\)</span> <em>is injective on</em> <span class="math notranslate nohighlight">\(A\)</span> if for every <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(x_2\)</span> in <span class="math notranslate nohighlight">\(A\)</span>, if <span class="math notranslate nohighlight">\(f(x_1) = f(x_2)\)</span>, then <span class="math notranslate nohighlight">\(x_1 = x_2\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(f\)</span> is a function from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span> and <span class="math notranslate nohighlight">\(A\)</span> is a subset of <span class="math notranslate nohighlight">\(X\)</span>, we write <span class="math notranslate nohighlight">\(f[A]\)</span> to denote the <em>image of</em> <span class="math notranslate nohighlight">\(f\)</span> <em>on</em> <span class="math notranslate nohighlight">\(A\)</span>, defined by</p>
<div class="math notranslate nohighlight">
\[f[A] = \{ y \in Y \mid y = f(x) \; \mbox{for some $x$ in $A$} \}.\]</div>
<p>In words, <span class="math notranslate nohighlight">\(f[A]\)</span> is the set of elements of <span class="math notranslate nohighlight">\(Y\)</span> that are &#8220;hit&#8221; by elements of <span class="math notranslate nohighlight">\(A\)</span> under the mapping <span class="math notranslate nohighlight">\(f\)</span>. Notice that there is an implicit existential quantifier here, so that reasoning about images invariably involves the corresponding rules.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math notranslate nohighlight">\(f : X \to Y\)</span>, and <span class="math notranslate nohighlight">\(A\)</span> is a subset of <span class="math notranslate nohighlight">\(X\)</span>. Then for any <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(f(x)\)</span> is in <span class="math notranslate nohighlight">\(f[A]\)</span>.</p>
<p><strong>Proof.</strong> By definition, <span class="math notranslate nohighlight">\(f(x)\)</span> is in <span class="math notranslate nohighlight">\(f[A]\)</span> if and only if there is some <span class="math notranslate nohighlight">\(x'\)</span> in <span class="math notranslate nohighlight">\(A\)</span> such that <span class="math notranslate nohighlight">\(f(x') = f(x)\)</span>. But that holds for <span class="math notranslate nohighlight">\(x' = x\)</span>.</p>
<p><strong>Proposition.</strong> Suppose <span class="math notranslate nohighlight">\(f : X \to Y\)</span> and <span class="math notranslate nohighlight">\(g : Y \to Z\)</span>. Let <span class="math notranslate nohighlight">\(A\)</span> be a subset of <span class="math notranslate nohighlight">\(X\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[(g \circ f)[A] = g[f[A]].\]</div>
<p><strong>Proof.</strong> Suppose <span class="math notranslate nohighlight">\(z\)</span> is in <span class="math notranslate nohighlight">\((g \circ f)[A]\)</span>. Then for some <span class="math notranslate nohighlight">\(x \in A\)</span>, <span class="math notranslate nohighlight">\(z = (g \circ f)(x) = g(f(x))\)</span>. By the previous proposition, <span class="math notranslate nohighlight">\(f(x)\)</span> is in <span class="math notranslate nohighlight">\(f[A]\)</span>. Again by the previous proposition, <span class="math notranslate nohighlight">\(g(f(x))\)</span> is in <span class="math notranslate nohighlight">\(g[f[A]]\)</span>.</p>
<p>Conversely, suppose <span class="math notranslate nohighlight">\(z\)</span> is in <span class="math notranslate nohighlight">\(g[f[A]]\)</span>. Then there is a <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(f[A]\)</span> such that <span class="math notranslate nohighlight">\(f(y) = z\)</span>, and since <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(f[D]\)</span>, there is an <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(A\)</span> such that <span class="math notranslate nohighlight">\(f(x) = y\)</span>. But then <span class="math notranslate nohighlight">\((g \circ f)(x) = g(f(x)) = g(y) = z\)</span>, so <span class="math notranslate nohighlight">\(z\)</span> is in <span class="math notranslate nohighlight">\((g \circ f)[A]\)</span>.</p>
<hr class="docutils" />
<p>Notice that if <span class="math notranslate nohighlight">\(f\)</span> is a function from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>, then <span class="math notranslate nohighlight">\(f\)</span> is surjective if and only if <span class="math notranslate nohighlight">\(f[X] = Y\)</span>. So the previous proposition is a generalization of the fact that the composition of surjective functions is surjective.</p>
<p>Suppose <span class="math notranslate nohighlight">\(f\)</span> is a function from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>, and <span class="math notranslate nohighlight">\(A\)</span> is a subset of <span class="math notranslate nohighlight">\(X\)</span>. We can <em>view</em> <span class="math notranslate nohighlight">\(f\)</span> as a function from <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>, by simply ignoring the behavior of <span class="math notranslate nohighlight">\(f\)</span> on elements outside of <span class="math notranslate nohighlight">\(A\)</span>. Properly speaking, this is another function, denoted <span class="math notranslate nohighlight">\(f \upharpoonright A\)</span> and called &#8220;the restriction of <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(A\)</span>.&#8221; In other words, given <span class="math notranslate nohighlight">\(f : X \to Y\)</span> and <span class="math notranslate nohighlight">\(A \subseteq X\)</span>, <span class="math notranslate nohighlight">\(f \upharpoonright A : A \to Y\)</span> is the function defined by <span class="math notranslate nohighlight">\((f \upharpoonright A)(x) = x\)</span> for every <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(A\)</span>. Notice that now &#8220;<span class="math notranslate nohighlight">\(f\)</span> is injective on <span class="math notranslate nohighlight">\(A\)</span>&#8221; means simply that the restriction of <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(A\)</span> is injective.</p>
<p>There is another important operation on functions, known as the <em>preimage</em>. If <span class="math notranslate nohighlight">\(f : X \to Y\)</span> and <span class="math notranslate nohighlight">\(B \subseteq Y\)</span>, then the <em>preimage of</em> <span class="math notranslate nohighlight">\(B\)</span> <em>under</em> <span class="math notranslate nohighlight">\(f\)</span>, denoted <span class="math notranslate nohighlight">\(f^{-1}[B]\)</span>, is defined by</p>
<div class="math notranslate nohighlight">
\[f^{-1}[B] = \{ x \in X \mid f(x) \in B \},\]</div>
<p>that is, the set of elements of <span class="math notranslate nohighlight">\(X\)</span> that get mapped into <span class="math notranslate nohighlight">\(B\)</span>. Notice that this makes sense even if <span class="math notranslate nohighlight">\(f\)</span> does not have an inverse; for a given <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(B\)</span>, there may be no <span class="math notranslate nohighlight">\(x\)</span>&#8217;s with the property <span class="math notranslate nohighlight">\(f(x) \in B\)</span>, or there may be many. If <span class="math notranslate nohighlight">\(f\)</span> has an inverse, <span class="math notranslate nohighlight">\(f^{-1}\)</span>, then for every <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(B\)</span> there is exactly one <span class="math notranslate nohighlight">\(x \in X\)</span> with the property <span class="math notranslate nohighlight">\(f(x) \in B\)</span>, in which case, <span class="math notranslate nohighlight">\(f^{-1}[B]\)</span> means the same thing whether you interpret it as the image of <span class="math notranslate nohighlight">\(B\)</span> under <span class="math notranslate nohighlight">\(f^{-1}\)</span> or the preimage of <span class="math notranslate nohighlight">\(B\)</span> under <span class="math notranslate nohighlight">\(f\)</span>.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Suppose <span class="math notranslate nohighlight">\(f : X \to Y\)</span> and <span class="math notranslate nohighlight">\(g : Y \to Z\)</span>. Let <span class="math notranslate nohighlight">\(C\)</span> be a subset of <span class="math notranslate nohighlight">\(Z\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[(g \circ f)^{-1}[C] = f^{-1}[g^{-1}[C]].\]</div>
<p><strong>Proof.</strong> For any <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(C\)</span>, <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\((g \circ f)^{-1}[C]\)</span> if and only if <span class="math notranslate nohighlight">\(g(f(y))\)</span> is in <span class="math notranslate nohighlight">\(C\)</span>. This, in turn, happens if and only if <span class="math notranslate nohighlight">\(f(y)\)</span> is in <span class="math notranslate nohighlight">\(g^{-1}[C]\)</span>, which in turn happens if and only if <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(f^{-1}[g^{-1}[C]]\)</span>.</p>
<hr class="docutils" />
<p>Here we give a long list of facts properties of images and preimages. Here, <span class="math notranslate nohighlight">\(f\)</span> denotes an arbitrary function from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>, <span class="math notranslate nohighlight">\(A, A_1, A_2, \ldots\)</span> denote arbitrary subsets of <span class="math notranslate nohighlight">\(X\)</span>, and <span class="math notranslate nohighlight">\(B, B_1, B_2, \ldots\)</span> denote arbitrary subsets of <span class="math notranslate nohighlight">\(Y\)</span>.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A \subseteq f^{-1}[f[A]]\)</span>, and if <span class="math notranslate nohighlight">\(f\)</span> is injective, <span class="math notranslate nohighlight">\(A = f^{-1}[f[A]]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f[f^{-1}[B]] \subseteq B\)</span>, and if <span class="math notranslate nohighlight">\(f\)</span> is surjective, <span class="math notranslate nohighlight">\(B = f[f^{-1}[B]]\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(A_1 \subseteq A_2\)</span>, then <span class="math notranslate nohighlight">\(f[A_1] \subseteq f[A_2]\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(B_1 \subseteq B_2\)</span>, then <span class="math notranslate nohighlight">\(f^{-1}[B_1] \subseteq f^{-1}[B_2]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f[A_1 \cup A_2] = f[A_1] \cup f[A_2]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f^{-1}[B_1 \cup B_2] = f^{-1}[B_1] \cup f^{-1}[B_2]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f[A_1 \cap A_2] \subseteq f[A_1] \cap f[A_2]\)</span>, and if <span class="math notranslate nohighlight">\(f\)</span> is injective, <span class="math notranslate nohighlight">\(f[A_1 \cap A_2] = f[A_1] \cap f[A_2]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f^{-1}[B_1 \cap B_2] = f^{-1}[B_1] \cap f^{-1}[B_2]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f[A_1] \setminus f[A_2] \subseteq f[A_1 \setminus A_2]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f^{-1}[B_1] \setminus f^{-1}[B_2] \subseteq f^{-1}[B_1 \setminus B_2]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f[A] \cap B = f[A \cap f^{-1}[B]]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(f[A] \cup B \supseteq f[A \cup f^{-1}[B]]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(A \cap f^{-1}[B] \subseteq f^{-1}[f[A] \cap B]\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(A \cup f^{-1}[B] \subseteq f^{-1}[f[A] \cup B]\)</span>.</p></li>
</ul>
<p>Proving identities like this is typically a matter of unfolding definitions and using basic logical inferences. Here is an example.</p>
<hr class="docutils" />
<p><strong>Proposition.</strong> Let <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> be sets, <span class="math notranslate nohighlight">\(f : X \to Y\)</span>, <span class="math notranslate nohighlight">\(A \subseteq X\)</span>, and <span class="math notranslate nohighlight">\(B \subseteq Y\)</span>. Then <span class="math notranslate nohighlight">\(f[A] \cap B = f[A \cap f^{-1}[B]]\)</span>.</p>
<p><strong>Proof.</strong> Suppose <span class="math notranslate nohighlight">\(y \in f[A] \cap B\)</span>. Then <span class="math notranslate nohighlight">\(y \in B\)</span>, and for some <span class="math notranslate nohighlight">\(x \in A\)</span>, <span class="math notranslate nohighlight">\(f(x) = y\)</span>. But this means that <span class="math notranslate nohighlight">\(x\)</span> is in <span class="math notranslate nohighlight">\(f^{-1}[B]\)</span>, and so <span class="math notranslate nohighlight">\(x \in A \cap f^{-1}[B]\)</span>. Since <span class="math notranslate nohighlight">\(f(x) = y\)</span>, we have <span class="math notranslate nohighlight">\(y \in f[A \cap f^{-1}[B]]\)</span>, as needed.</p>
<p>Conversely, suppose <span class="math notranslate nohighlight">\(y \in f[A \cap f^{-1}[B]]\)</span>. Then for some <span class="math notranslate nohighlight">\(x \in A \cap f^{-1}[B]\)</span>, we have <span class="math notranslate nohighlight">\(f(x) = y\)</span>. For this <span class="math notranslate nohighlight">\(x\)</span>, have <span class="math notranslate nohighlight">\(x \in A\)</span> and <span class="math notranslate nohighlight">\(f(x) \in B\)</span>. Since <span class="math notranslate nohighlight">\(f(x) = y\)</span>, we have <span class="math notranslate nohighlight">\(y \in B\)</span>, and since <span class="math notranslate nohighlight">\(x \in A\)</span>, we also have <span class="math notranslate nohighlight">\(y \in f[A]\)</span>, as required.</p>
<hr class="docutils" />
</div>
<div class="section" id="functions-and-relations">
<span id="id3"></span><h2><span class="section-number">15.4. </span>Functions and Relations<a class="headerlink" href="#functions-and-relations" title="Permalink to this headline">&#182;</a></h2>
<p>A binary relation <span class="math notranslate nohighlight">\(R(x,y)\)</span> on <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> is <em>functional</em> if for every <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(A\)</span> there exists a unique <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(B\)</span> such that <span class="math notranslate nohighlight">\(R(x,y)\)</span>. If <span class="math notranslate nohighlight">\(R\)</span> is a functional relation, we can define a function <span class="math notranslate nohighlight">\(f_R : X \to B\)</span> by setting <span class="math notranslate nohighlight">\(f_R(x)\)</span> to be equal to the unique <span class="math notranslate nohighlight">\(y\)</span> in <span class="math notranslate nohighlight">\(B\)</span> such that <span class="math notranslate nohighlight">\(R(x,y)\)</span>. Conversely, it is not hard to see that if <span class="math notranslate nohighlight">\(f : X \to B\)</span> is any function, the relation <span class="math notranslate nohighlight">\(R_f(x, y)\)</span> defined by <span class="math notranslate nohighlight">\(f(x) = y\)</span> is a functional relation. The relation <span class="math notranslate nohighlight">\(R_f(x,y)\)</span> is known as the <em>graph</em> of <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>It is not hard to check that functions and relations travel in pairs: if <span class="math notranslate nohighlight">\(f\)</span> is the function associated with a functional relation <span class="math notranslate nohighlight">\(R\)</span>, then <span class="math notranslate nohighlight">\(R\)</span> is the functional relation associated the function <span class="math notranslate nohighlight">\(f\)</span>, and vice-versa. In set-theoretic foundations, a function is often defined to be a functional relation. Conversely, we have seen that in type-theoretic foundations like the one adopted by Lean, relations are often defined to be certain types of functions. We will discuss these matters later on, and in the meanwhile only remark that in everyday mathematical practice, the foundational details are not so important; what is important is simply that every function has a graph, and that any functional relation can be used to define a corresponding function.</p>
<p>So far, we have been focusing on functions that take a single argument. We can also consider functions <span class="math notranslate nohighlight">\(f(x, y)\)</span> or <span class="math notranslate nohighlight">\(g(x, y, z)\)</span> that take multiple arguments. For example, the addition function <span class="math notranslate nohighlight">\(f(x, y) = x + y\)</span> on the integers takes two integers and returns an integer. Remember, we can consider binary functions, ternary functions, and so on, and the number of arguments to a function is called its &#8220;arity.&#8221; One easy way to make sense of functions with multiple arguments is to think of them as unary functions from a cartesian product. We can think of a function <span class="math notranslate nohighlight">\(f\)</span> which takes two arguments, one in <span class="math notranslate nohighlight">\(A\)</span> and one in <span class="math notranslate nohighlight">\(B\)</span>, and returns an argument in <span class="math notranslate nohighlight">\(C\)</span> as a unary function from <span class="math notranslate nohighlight">\(A \times B\)</span> to <span class="math notranslate nohighlight">\(C\)</span>, whereby <span class="math notranslate nohighlight">\(f(a, b)\)</span> abbreviates <span class="math notranslate nohighlight">\(f((a, b))\)</span>. We have seen that in dependent type theory (and in Lean) it is more convenient to think of such a function <span class="math notranslate nohighlight">\(f\)</span> as a function which takes an element of <span class="math notranslate nohighlight">\(A\)</span> and returns a function from <span class="math notranslate nohighlight">\(B \to C\)</span>, so that <span class="math notranslate nohighlight">\(f(a, b)\)</span> abbreviates <span class="math notranslate nohighlight">\((f(a))(b)\)</span>. Such a function <span class="math notranslate nohighlight">\(f\)</span> maps <span class="math notranslate nohighlight">\(A\)</span> to <span class="math notranslate nohighlight">\(B \to C\)</span>, where <span class="math notranslate nohighlight">\(B \to C\)</span> is the set of functions from <span class="math notranslate nohighlight">\(B\)</span> to <span class="math notranslate nohighlight">\(C\)</span>.</p>
<p>We will return to these different ways of modeling functions of higher arity later on, when we consider set-theoretic and type-theoretic foundations. One again, we remark that in ordinary mathematics, the foundational details do not matter much. The two choices above are inter-translatable, and sanction the same principles for reasoning about functions informally.</p>
<p>In mathematics, we often also consider the notion of a <em>partial function</em> from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>, which is really a function from some subset of <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>. The fact that <span class="math notranslate nohighlight">\(f\)</span> is a partial function from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span> is sometimes written <span class="math notranslate nohighlight">\(f : X \nrightarrow Y\)</span>, which should be interpreted as saying that <span class="math notranslate nohighlight">\(f : A \to Y\)</span> for some subset <span class="math notranslate nohighlight">\(A\)</span> of <span class="math notranslate nohighlight">\(Y\)</span>. Intuitively, we think of <span class="math notranslate nohighlight">\(f\)</span> as a function from <span class="math notranslate nohighlight">\(X \to Y\)</span> which is simply &#8220;undefined&#8221; at some of its inputs; for example, we can think of <span class="math notranslate nohighlight">\(f : \mathbb{R} \nrightarrow \mathbb{R}\)</span> defined by <span class="math notranslate nohighlight">\(f(x) = 1 / x\)</span>, which is undefined at <span class="math notranslate nohighlight">\(x = 0\)</span>, so that in reality <span class="math notranslate nohighlight">\(f : \mathbb{R} \setminus \{ 0 \} \to R\)</span>. The set <span class="math notranslate nohighlight">\(A\)</span> is sometimes called the <em>domain of</em> <span class="math notranslate nohighlight">\(f\)</span>, in which case, there is no good name for <span class="math notranslate nohighlight">\(X\)</span>; others continue to call <span class="math notranslate nohighlight">\(X\)</span> the domain, and refer to <span class="math notranslate nohighlight">\(A\)</span> as the <em>domain of definition</em>. To indicate that a function <span class="math notranslate nohighlight">\(f\)</span> is defined at <span class="math notranslate nohighlight">\(x\)</span>, that is, that <span class="math notranslate nohighlight">\(x\)</span> is in the domain of definition of <span class="math notranslate nohighlight">\(f\)</span>, we sometimes write <span class="math notranslate nohighlight">\(f(x) \downarrow\)</span>. If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are two partial functions from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>, we write <span class="math notranslate nohighlight">\(f(x) \simeq g(x)\)</span> to mean that either <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are both defined at <span class="math notranslate nohighlight">\(x\)</span> and have the same value, or are both undefined at <span class="math notranslate nohighlight">\(x\)</span>. Notions of injectivity, surjectivity, and composition are extended to partial functions, generally as you would expect them to be.</p>
<p>In terms of relations, a partial function <span class="math notranslate nohighlight">\(f\)</span> corresponds to a relation <span class="math notranslate nohighlight">\(R_f(x,y)\)</span> such that for every <span class="math notranslate nohighlight">\(x\)</span> there is at most one <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(R_f(x,y)\)</span> holds. Mathematicians also sometimes consider <em>multifunctions</em> from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>, which correspond to relations <span class="math notranslate nohighlight">\(R_f(x,y)\)</span> such that for every <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(X\)</span>, there is <em>at least</em> one <span class="math notranslate nohighlight">\(y\)</span> such that <span class="math notranslate nohighlight">\(R_f(x,y)\)</span> holds. There may be many such <span class="math notranslate nohighlight">\(y\)</span>; you can think of these as functions which have more than one output value. If you think about it for a moment, you will see that a <em>partial multifunction</em> is essentially nothing more than an arbitrary relation.</p>
</div>
<div class="section" id="exercises">
<h2><span class="section-number">15.5. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h2>
<ol class="arabic simple">
<li><p>Let <span class="math notranslate nohighlight">\(f\)</span> be any function from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span>, and let <span class="math notranslate nohighlight">\(g\)</span> be any function from <span class="math notranslate nohighlight">\(Y\)</span> to <span class="math notranslate nohighlight">\(Z\)</span>.</p>
<ul class="simple">
<li><p>Show that if <span class="math notranslate nohighlight">\(g \circ f\)</span> is injective, then <span class="math notranslate nohighlight">\(f\)</span> is injective.</p></li>
<li><p>Give an example of functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> as above, such that that <span class="math notranslate nohighlight">\(g \circ f\)</span> is injective, but <span class="math notranslate nohighlight">\(g\)</span> is not injective.</p></li>
<li><p>Show that if <span class="math notranslate nohighlight">\(g \circ f\)</span> is injective and <span class="math notranslate nohighlight">\(f\)</span> is surjective, then <span class="math notranslate nohighlight">\(g\)</span> is injective.</p></li>
</ul>
</li>
<li><p>Let <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> be as in the last problem. Suppose <span class="math notranslate nohighlight">\(g \circ f\)</span> is surjective.</p>
<ul class="simple">
<li><p>Is <span class="math notranslate nohighlight">\(f\)</span> necessarily surjective? Either prove that it is, or give a counterexample.</p></li>
<li><p>Is <span class="math notranslate nohighlight">\(g\)</span> necessarily surjective? Either prove that it is, or give a counterexample.</p></li>
</ul>
</li>
<li><p>A function <span class="math notranslate nohighlight">\(f\)</span> from <span class="math notranslate nohighlight">\(\mathbb{R}\)</span> to <span class="math notranslate nohighlight">\(\mathbb{R}\)</span> is said to be
<em>strictly increasing</em> if whenever <span class="math notranslate nohighlight">\(x_1 &lt; x_2\)</span>, <span class="math notranslate nohighlight">\(f(x_1) &lt; f(x_2)\)</span>.</p>
<ul class="simple">
<li><p>Show that if <span class="math notranslate nohighlight">\(f : \mathbb{R} \to \mathbb{R}\)</span> is strictly increasing, then it is injective (and hence it has a left inverse).</p></li>
<li><p>Show that if <span class="math notranslate nohighlight">\(f : \mathbb{R} \to \mathbb{R}\)</span> is strictly increasing, and <span class="math notranslate nohighlight">\(g\)</span> is a right inverse to <span class="math notranslate nohighlight">\(f\)</span>, then <span class="math notranslate nohighlight">\(g\)</span> is
strictly increasing.</p></li>
</ul>
</li>
<li><p>Let <span class="math notranslate nohighlight">\(f : X \to Y\)</span> be any function, and let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be subsets of <span class="math notranslate nohighlight">\(X\)</span>. Show that <span class="math notranslate nohighlight">\(f [A \cup B] = f[A] \cup f[B]\)</span>.</p></li>
<li><p>Let <span class="math notranslate nohighlight">\(f: X \to Y\)</span> be any function, and let <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> be any subsets of <span class="math notranslate nohighlight">\(X\)</span>. Show <span class="math notranslate nohighlight">\(f[A] \setminus f[B] \subseteq f[A \setminus B]\)</span>.</p></li>
<li><p>Define notions of composition and inverse for binary relations that generalize the notions for functions.</p></li>
</ol>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Logic and Proof</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_propositional_logic.html">3. Natural Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">4. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_reasoning.html">5. Classical Reasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_propositional_logic.html">6. Semantics of Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">7. First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_first_order_logic.html">8. Natural Deduction for First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">9. First Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_first_order_logic.html">10. Semantics of First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets.html">11. Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_in_lean.html">12. Sets in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations.html">13. Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations_in_lean.html">14. Relations in Lean</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">15. Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-function-concept">15.1. The Function Concept</a></li>
<li class="toctree-l2"><a class="reference internal" href="#injective-surjective-and-bijective-functions">15.2. Injective, Surjective, and Bijective Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functions-and-subsets-of-the-domain">15.3. Functions and Subsets of the Domain</a></li>
<li class="toctree-l2"><a class="reference internal" href="#functions-and-relations">15.4. Functions and Relations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">15.5. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functions_in_lean.html">16. Functions in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction.html">17. The Natural Numbers and Induction</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction_in_lean.html">18. The Natural Numbers and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory.html">19. Elementary Number Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorics.html">20. Combinatorics</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_real_numbers.html">21. The Real Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_infinite.html">22. The Infinite</a></li>
<li class="toctree-l1"><a class="reference internal" href="axiomatic_foundations.html">23. Axiomatic Foundations</a></li>
<li class="toctree-l1"><a class="reference internal" href="nd_quickref.html">24. Appendix: Natural Deduction Rules</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="logic_and_proof.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/functions.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>