
<!DOCTYPE html>

<html>
  <head>
    <meta charset="ascii" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>23. Axiomatic Foundations &#8212; Logic and Proof 3.18.4 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="24. Appendix: Natural Deduction Rules" href="nd_quickref.html" />
    <link rel="prev" title="22. The Infinite" href="the_infinite.html" />
<!-- <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=Average" rel="stylesheet"> -->
<!-- <link href="https://fonts.googleapis.com/css?family=EB+Garamond" rel="stylesheet"> -->

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="axiomatic-foundations">
<span id="id1"></span><h1><span class="section-number">23. </span>Axiomatic Foundations<a class="headerlink" href="#axiomatic-foundations" title="Permalink to this headline">&#182;</a></h1>
<p>In this final chapter, our story comes full circle. We started our journey with symbolic logic, using the propositional connectives to model logical terms like &#8220;and,&#8221; &#8220;or,&#8221; &#8220;not,&#8221; and &#8220;implies.&#8221; To that we added the quantifiers and function and relation symbols of first-order logic. From there, we moved to sets, functions, and relations, which are ubiquitous in modern mathematics; the natural numbers and induction; and then topics such as number theory, combinatorics, the real numbers, and the infinite. Here we return to symbolic logic, and see how it can be used to provide a formal foundation for all of mathematics.</p>
<p>Specifically, we will consider an axiomatic framework known as <em>Zermelo-Fraenkel set theory</em>, which was introduced early in the twentieth century. In the set-theoretic view of mathematics, every mathematical object is a set. The axioms assert the existence of sets with various properties. From the collection of all sets, we carve out the usual inhabitants of the mathematical universe, not just the various number systems we have considered, but also pairs, finite sequences, relations, functions, and so on. This provides us with an idealized foundation for everything we have done since <a class="reference internal" href="sets.html#sets"><span class="std std-numref">Chapter 11</span></a>.</p>
<p>At the end of this chapter, we will briefly describe another axiomatic framework, <em>dependent type theory</em>, which is the one used by Lean. We will see that it provides an alternative perspective on mathematical objects and constructions, but one which is nonetheless inter-interpretable with the set-theoretic point of view.</p>
<div class="section" id="basic-axioms-for-sets">
<span id="id2"></span><h2><span class="section-number">23.1. </span>Basic Axioms for Sets<a class="headerlink" href="#basic-axioms-for-sets" title="Permalink to this headline">&#182;</a></h2>
<p>The axioms of set theory are expressed in first-order logic, for a language with a single binary relation symbol, <span class="math notranslate nohighlight">\(\mathord{\in}\)</span>. We think of the entire mathematical universe as consisting of nothing but sets; if <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are sets, we can express that <span class="math notranslate nohighlight">\(x\)</span> is an element of <span class="math notranslate nohighlight">\(y\)</span> by writing <span class="math notranslate nohighlight">\(x \in y\)</span>. The first axiom says that two sets are equal if and only if they have the same elements.</p>
<div class="math notranslate nohighlight">
\[\text{Extensionality:} \;\; \forall x, y \; (x = y \leftrightarrow \forall z (z \in x \leftrightarrow z \in y))\]</div>
<p>The next axiom tells us that there is at least one interesting set in the universe, namely, the set with no element.</p>
<div class="math notranslate nohighlight">
\[\text{Empty set:} \;\; \exists x \; \forall y \; y \notin x\]</div>
<p>Here, of course, <span class="math notranslate nohighlight">\(x \notin y\)</span> abbreviates <span class="math notranslate nohighlight">\(\neg (x \in y)\)</span>. By the axiom of extensionality, the set asserted to exist by this axiom is unique: in other words, if <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(x_2\)</span> each have no elements, then, vacuously, any element is in one if and only if it is in the other, so <span class="math notranslate nohighlight">\(x_1 = x_2\)</span>. This justifies using the word <em>the</em> in the phrase <em>the empty set</em>. Given this fact, it should seem harmless to introduce a new symbol, <span class="math notranslate nohighlight">\(\emptyset\)</span>, to denote the set matching that description. Indeed, one can show that this is case: in a precise sense, such expansions to a first-order language can be viewed as nothing more than a convenient manner of expression, and statements in the bigger language can be translated to the original language in a way that justifies all the expected inferences. We will not go into the details here, and, rather, take this fact for granted. Using the new symbol, the empty set axiom tells us the empty set satisfies the property <span class="math notranslate nohighlight">\(\forall y \; y \notin \emptyset\)</span>.</p>
<p>The third axiom tells us that given two sets <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, we can form a new set <span class="math notranslate nohighlight">\(z\)</span> whose elements are exactly <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>.</p>
<div class="math notranslate nohighlight">
\[\text{Pairing:} \;\; \forall x, y \; \exists z \; \forall w \; (w \in z \leftrightarrow w = x \vee w = y)\]</div>
<p>There is a stealth usage of this axiom lurking nearby. The axiom does not require that <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are different, so, for example, we can take them both to be the empty set. This tells us that the set <span class="math notranslate nohighlight">\(\{ \emptyset \}\)</span>, whose only element is the empty set, exists. More generally, the axiom tells us that for any <span class="math notranslate nohighlight">\(x\)</span>, we have the set <span class="math notranslate nohighlight">\(\{ x \}\)</span> whose only element is <span class="math notranslate nohighlight">\(x\)</span>, and for any <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, we have <span class="math notranslate nohighlight">\(\{x, y\}\)</span>, as described above. Once again, the axiom of extensionality tells us that the sets meeting these descriptions are unique, so it is fair to use the corresponding notation. We are now off and running! We now have all of the following sets, and more:</p>
<div class="math notranslate nohighlight">
\[\emptyset, \;\; \{ \emptyset \}, \; \; \{ \{ \emptyset \} \}, \;\; \{ \emptyset, \{ \emptyset \} \}, \;\; \{ \{ \{ \emptyset \} \} \}, \;\; \ldots\]</div>
<p>Still, we can never form a set with more than two elements in this way. To that end, it would be reasonable to add an axiom that asserts for every <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, the set <span class="math notranslate nohighlight">\(x \cup y\)</span> exists. But we can do better. Remember that if <span class="math notranslate nohighlight">\(x\)</span> is any set, <span class="math notranslate nohighlight">\(\bigcup x\)</span> denotes the union of all the sets in <span class="math notranslate nohighlight">\(x\)</span>. In other words, for any set <span class="math notranslate nohighlight">\(z\)</span>, <span class="math notranslate nohighlight">\(z\)</span> is an element of <span class="math notranslate nohighlight">\(\bigcup x\)</span> if and only if <span class="math notranslate nohighlight">\(z\)</span> is in <span class="math notranslate nohighlight">\(w\)</span> for some set <span class="math notranslate nohighlight">\(w\)</span> in <span class="math notranslate nohighlight">\(x\)</span>. The following axiom asserts that this set exists.</p>
<div class="math notranslate nohighlight">
\[\text{Union:} \;\; \forall x \; \exists y \; \forall z \; (z \in y \leftrightarrow \exists w \; (w \in x \wedge z \in w))\]</div>
<p>Once again, this justifies the use of the <span class="math notranslate nohighlight">\(\bigcup\)</span> notation. We get the ordinary binary union using this axiom together with pairing, since we have <span class="math notranslate nohighlight">\(x \cup y = \bigcup \{ x, y \}\)</span>.</p>
<p>At this stage, it will be useful to invoke some additional notation that was first introduced in our informal presentation of sets. If <span class="math notranslate nohighlight">\(A\)</span> is any first-order formula in the language of set theory, <span class="math notranslate nohighlight">\(\forall x \in y \; A\)</span> abbreviates <span class="math notranslate nohighlight">\(\forall x \; (x \in y \rightarrow A)\)</span> and <span class="math notranslate nohighlight">\(\exists x \in y \; A\)</span> abbreviates <span class="math notranslate nohighlight">\(\exists x \; (x \in y \wedge A)\)</span>, relativizing the quantifiers as described in <a class="reference internal" href="first_order_logic.html#relativization-and-sorts"><span class="std std-numref">Section 7.4</span></a>. The expression <span class="math notranslate nohighlight">\(x \subseteq y\)</span> abbreviates <span class="math notranslate nohighlight">\(\forall z \in x \; (z \in y)\)</span>, as you would expect.</p>
<p>The next axiom asserts that for every set <span class="math notranslate nohighlight">\(x\)</span>, the power set, <span class="math notranslate nohighlight">\(\mathcal{P}(x)\)</span> exists.</p>
<div class="math notranslate nohighlight">
\[\text{Power Set:} \;\; \forall x \; \exists y \; \forall z \; (z \in y \leftrightarrow z \subseteq x)\]</div>
<p>We have begun to populate the universe with basic set constructions. It is the next axiom, however, that gives set theory its remarkable flexibility. Properly speaking, it is not a single axiom, but a <em>schema</em>, an infinite family of axioms given by a single template. The schema is meant to justify set-builder notation <span class="math notranslate nohighlight">\(\{ w \mid \ldots \}\)</span> that was ubiquitous in <a class="reference internal" href="sets.html#sets"><span class="std std-numref">Chapter 11</span></a>. The first question we need to address is what we are allowed to write in place of the ellipsis. In our informal presentation of set theory, we said that one can define a set using any property, but that only prompts the question here as to what counts as a &#8220;property.&#8221; Axiomatic set theory provides a simple but powerful answer: we can use any first-order formula in the language of set theory.</p>
<p>Another concern centers around Russell&#8217;s paradox, as discussed in <a class="reference internal" href="sets.html#elementary-set-theory"><span class="std std-numref">Section 11.1</span></a>. Any theory that allows us to define the set <span class="math notranslate nohighlight">\(\{ w \mid w \notin w \}\)</span> is inconsistent, since if we call this set <span class="math notranslate nohighlight">\(z\)</span>, we can show <span class="math notranslate nohighlight">\(z \in z\)</span> if and only if <span class="math notranslate nohighlight">\(z \notin z\)</span>, which is a contradiction. Once again, set theory offers a simple and elegant solution: for any formula <span class="math notranslate nohighlight">\(A(z)\)</span> and set <span class="math notranslate nohighlight">\(y\)</span>, we can instead form the set <span class="math notranslate nohighlight">\(\{ w \in y \mid A(w) \}\)</span>, consisting of the elements of <span class="math notranslate nohighlight">\(y\)</span> that satisfy <span class="math notranslate nohighlight">\(A\)</span>. In other words, we have to first use the other axioms of set theory to form a set <span class="math notranslate nohighlight">\(y\)</span> that is big enough to include all the elements that we want to consider, and then use the formula <span class="math notranslate nohighlight">\(A\)</span> to pick out the ones we want.</p>
<p>The axiom schema we want is called <em>separation</em>, because we use it to separate the elements we want from those in a bigger collection.</p>
<div class="math notranslate nohighlight">
\[\text{Separation:} \;\; \forall x_1, x_2, \ldots, x_n, y \; \exists z \; \forall w \; (w \in z \leftrightarrow w \in y \wedge A(w,x_1, x_2, \ldots, x_n))\]</div>
<p>Here, <span class="math notranslate nohighlight">\(A\)</span> can be any formula, and the list of variables <span class="math notranslate nohighlight">\(x_1, \ldots, x_n\)</span> that are shown indicate that the formula <span class="math notranslate nohighlight">\(A\)</span> can have some parameters, in which case the set we form depends on these values. For example, in ordinary mathematics, given a number <span class="math notranslate nohighlight">\(m\)</span> we can form the set <span class="math notranslate nohighlight">\(\{ n \in \mathbb{N} \mid \mathit{prime}(n) \wedge n &gt; m\}\)</span>. In this example, the description involves <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span>, and the set so defined depends on <span class="math notranslate nohighlight">\(m\)</span>.</p>
<p>We could use the separation axiom to simplify the previous axioms. For example, as long as we know that <em>any</em> set <span class="math notranslate nohighlight">\(x\)</span> exists, we can define the empty set as <span class="math notranslate nohighlight">\(\{ y \in x \mid \bot \}\)</span>. Similarly, in the pairing axiom, it is enough to assert that there is a set that contains <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> as elements, because then we can use separation to carve out the set whose elements are exactly <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>These are only the first six axioms of set theory; we have four more to go. But these axioms alone provide a foundation for reasoning about sets, relations, and functions, as we did in <a class="reference internal" href="sets.html#sets"><span class="std std-numref">Chapter 11</span></a>, <a class="reference internal" href="relations.html#relations"><span class="std std-numref">Chapter 13</span></a>, and <a class="reference internal" href="functions.html#functions"><span class="std std-numref">Chapter 15</span></a>. For example, we have already defined the union operation, and we can define set intersection <span class="math notranslate nohighlight">\(x \cap y\)</span> as <span class="math notranslate nohighlight">\(\{ z \in x \cup y \mid z \in x \wedge z \in y \}\)</span>.  We cannot define arbitrary set complements; for example, the exercises ask you to show that in set theory we can prove that there is no set that contains all sets, and so the complement of the empty set does not exist. But given any two sets <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, we can define their difference <span class="math notranslate nohighlight">\(x \setminus y\)</span> as <span class="math notranslate nohighlight">\(\{ z \in x \mid z \notin y \}\)</span>. The exercises below ask you to show that we can also define indexed unions and intersections, once we have developed the notion of a function.</p>
<p>We would like to define a binary relation between two sets <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> to be a subset of <span class="math notranslate nohighlight">\(x \times y\)</span>, but we first have to define the cartesian product <span class="math notranslate nohighlight">\(x \times y\)</span>. Remember that in <a class="reference internal" href="sets.html#cartesian-product-and-power-set"><span class="std std-numref">Section 11.4</span></a> we defined the ordered pair <span class="math notranslate nohighlight">\((u, v)\)</span> to be the set <span class="math notranslate nohighlight">\(\{ \{ u \}, \{ u, v \} \}\)</span>. As a result, we can use the separation axiom to define</p>
<div class="math notranslate nohighlight">
\[x \times y = \{ z \in \ldots \mid \exists u \in x \; \exists v \in y \; (z = (u, v)) \}\]</div>
<p>provided we can prove the existence of a set big enough to fill the &#8220;&#8230;.&#8221; In the exercises below, we ask you to show that the set <span class="math notranslate nohighlight">\(\mathcal P (\mathcal P (x \cup y))\)</span> contains all the relevant ordered pairs. A binary relation <span class="math notranslate nohighlight">\(r\)</span> on <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> is then just a subset of <span class="math notranslate nohighlight">\(x \times y\)</span>, where we interpret <span class="math notranslate nohighlight">\(r(u, v)\)</span> as <span class="math notranslate nohighlight">\((u, v) \in r\)</span>. We can think of ordered triples from the sets <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(z\)</span> as elements of <span class="math notranslate nohighlight">\(x \times (y \times z)\)</span> and so on. This gives us ternary relations, four-place relations, and so on.</p>
<p>Now we can say that a function <span class="math notranslate nohighlight">\(f : x \to y\)</span> is really a binary relation satisfying <span class="math notranslate nohighlight">\(\forall u \in x \; \exists! v \in y \; f(u, v)\)</span>, and we write <span class="math notranslate nohighlight">\(f(u) = v\)</span> when <span class="math notranslate nohighlight">\(v\)</span> is the unique element satisfying <span class="math notranslate nohighlight">\(f(u, v)\)</span>. A function <span class="math notranslate nohighlight">\(f\)</span> taking arguments from sets <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span> and returning an element of <cite>w</cite> can be interpreted as a function <span class="math notranslate nohighlight">\(f : x \times y \times z \to w\)</span>, and so on.</p>
<p>With sets, relations, and functions, we have the basic infrastructure we need to do mathematics. All we are missing at this point are some interesting sets and structures to work with. For example, it would be nice to have a set of natural numbers, <span class="math notranslate nohighlight">\(\mathbb{N}\)</span>, with all the properties we expect it to have. So let us turn to that next.</p>
</div>
<div class="section" id="the-axiom-of-infinity">
<h2><span class="section-number">23.2. </span>The Axiom of Infinity<a class="headerlink" href="#the-axiom-of-infinity" title="Permalink to this headline">&#182;</a></h2>
<p>With the axioms we have so far, we can form lots of finite sets, starting with <span class="math notranslate nohighlight">\(\emptyset\)</span> and iterating pairing, union, powerset, and separation constructions. This will give us sets like</p>
<div class="math notranslate nohighlight">
\[\emptyset, \{ \emptyset \}, \{ \{ \emptyset \} \}, \{ \emptyset, \{ \emptyset \} \}, \{ \{ \{ \emptyset \} \} \}, \ldots\]</div>
<p>But the axioms so far do not allow us to define sets that are more interesting than these. In particular, none of the axioms gives us an infinite set. So we need a further axiom to tell us that such a set exists.</p>
<p>Remember that in <a class="reference internal" href="the_natural_numbers_and_induction.html#the-natural-numbers-and-induction"><span class="std std-numref">Chapter 17</span></a> we characterized the natural numbers as a set with a distinguished element, <span class="math notranslate nohighlight">\(0\)</span>, and an injective operation <span class="math notranslate nohighlight">\(\mathit{succ}\)</span>, satisfying the principles of induction and recursive definition. In set theory, everything is a set, so if we want to represent the natural numbers in that framework, we need to identify them with particular sets. There is a natural choice for <span class="math notranslate nohighlight">\(0\)</span>, namely, the empty set, <span class="math notranslate nohighlight">\(\emptyset\)</span>. For a successor operation, we will use the function <span class="math notranslate nohighlight">\(\mathit{succ}\)</span> defined by <span class="math notranslate nohighlight">\(\mathit{succ}(x) = x \cup \{ x \}\)</span>. The choice is a bit of a hack; the best justification for the definition is that it works. With this definition, the first few natural numbers are as follows:</p>
<div class="math notranslate nohighlight">
\[0 = \emptyset, \;\; 1 = \{ \emptyset \}, \;\; 2 = \{ \emptyset, \{ \emptyset \} \}, \;\; 3 = \{ \emptyset, \{ \emptyset \}, \{ \emptyset, \{ \emptyset \} \} \}, \;\; \ldots\]</div>
<p>It is more perspicuous to write them as follows:</p>
<div class="math notranslate nohighlight">
\[0 = \emptyset, \;\; 1 = \{ 0 \}, \;\; 2 = \{ 0, 1 \}, \;\; 3 = \{ 0, 1, 2 \}, \;\; 4 = \{ 0, 1, 2, 3 \}, \;\; \ldots\]</div>
<p>In general, <span class="math notranslate nohighlight">\(n+1\)</span> is represented by the set <span class="math notranslate nohighlight">\(\{ 0, 1, \ldots, n \}\)</span>, in which case, <span class="math notranslate nohighlight">\(m \in n\)</span> is the same as <span class="math notranslate nohighlight">\(m &lt; n\)</span>. This is just an incidental property of our encoding, but it is a rather charming one.</p>
<p>Recall from <a class="reference internal" href="the_natural_numbers_and_induction.html#the-natural-numbers-and-induction"><span class="std std-numref">Chapter 17</span></a> that we can characterize the set of natural numbers as follows:</p>
<ul class="simple">
<li><p>There is an element <span class="math notranslate nohighlight">\(0 \in \mathbb{N}\)</span> and there is an injective function <span class="math notranslate nohighlight">\(\mathit{succ} : \mathbb{N} \to \mathbb{N}\)</span>, with the additional property that <span class="math notranslate nohighlight">\(\mathit{succ}(x) \ne 0\)</span> for any <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(\mathbb{N}\)</span>.</p></li>
<li><p>The set <span class="math notranslate nohighlight">\(\mathbb{N}\)</span> satisfies the principle of induction: if <span class="math notranslate nohighlight">\(x\)</span> is a subset of <span class="math notranslate nohighlight">\(\mathbb{N}\)</span> that contains <span class="math notranslate nohighlight">\(0\)</span> and is closed under <span class="math notranslate nohighlight">\(\mathit{succ}\)</span> (that is, whenever <span class="math notranslate nohighlight">\(z\)</span> is in <span class="math notranslate nohighlight">\(\mathbb{N}\)</span>, so is <span class="math notranslate nohighlight">\(\mathit{succ}\)</span>), then <span class="math notranslate nohighlight">\(x = \mathbb{N}\)</span>.</p></li>
</ul>
<p>We have already settled on the definitions of <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(\mathit{succ}\)</span>, but we don&#8217;t yet have any set that contains the first and is closed under applying the second. The axiom of infinity asserts precisely that there exists such a set.</p>
<div class="math notranslate nohighlight">
\[\text{Infinity:} \;\; \exists x \; (\emptyset \in x \wedge \forall y \; (y \in x \rightarrow y \cup \{ y \} \in x))\]</div>
<p>Say a set <span class="math notranslate nohighlight">\(x\)</span> is <em>inductive</em> if it satisfies the property after the existential quantifier, namely, that it contains the empty set and is closed under our successor operation. Notice that the set of natural numbers, which we are still trying to define formally, has this property. The axiom of infinity asserts the existence of <em>some</em> inductive set, but not necessarily the natural numbers themselves; an inductive set can have other things in it as well. In a sense, the principle of induction says that the natural numbers is the <em>smallest</em> inductive set. So we need a way to separate that set from the one asserted to exist by the axiom of infinity.</p>
<p>Let <span class="math notranslate nohighlight">\(x\)</span> be any inductive set, as asserted to exist by the axiom of infinity. Let</p>
<div class="math notranslate nohighlight">
\[y = \bigcap \{ z \subseteq x \mid \mbox{$z$ is inductive} \}.\]</div>
<p>Here <span class="math notranslate nohighlight">\(z \subseteq x\)</span> can also be written <span class="math notranslate nohighlight">\(z \in \mathcal P(x)\)</span>, so the inside set exists by the separation axiom. According to this definition, <span class="math notranslate nohighlight">\(y\)</span> is the intersection of every inductive subset of <span class="math notranslate nohighlight">\(x\)</span>, so an element <span class="math notranslate nohighlight">\(w\)</span> is in <span class="math notranslate nohighlight">\(y\)</span> if and only if <span class="math notranslate nohighlight">\(w\)</span> is in every inductive subset of <span class="math notranslate nohighlight">\(x\)</span>. We claim that <span class="math notranslate nohighlight">\(y\)</span> itself is inductive. First, we have <span class="math notranslate nohighlight">\(\emptyset \in y\)</span>, since the empty set is an element of every inductive set. Next, suppose <span class="math notranslate nohighlight">\(w\)</span> is in <span class="math notranslate nohighlight">\(y\)</span>. Then <span class="math notranslate nohighlight">\(w\)</span> is in every inductive subset of <span class="math notranslate nohighlight">\(x\)</span>. But since every inductive set is closed under successor, <span class="math notranslate nohighlight">\(\mathit{succ}(w)\)</span> is in every inductive subset of <span class="math notranslate nohighlight">\(x\)</span>. So <span class="math notranslate nohighlight">\(\mathit{succ}(w)\)</span> is in the intersection of all inductive subsets of <span class="math notranslate nohighlight">\(x\)</span>&#8212;which is <span class="math notranslate nohighlight">\(y\)</span>!</p>
<p>It quickly follows that <span class="math notranslate nohighlight">\(y\)</span> is a subset of <em>every</em> inductive set. To see this, suppose that <span class="math notranslate nohighlight">\(z\)</span> is inductive. You can check that <span class="math notranslate nohighlight">\(z \cap x\)</span> is inductive, and thus <span class="math notranslate nohighlight">\(y \subseteq z \cap x \subseteq z\)</span>.</p>
<p>The more interesting point is that <span class="math notranslate nohighlight">\(y\)</span> also satisfies the principle of induction. To see this, suppose <span class="math notranslate nohighlight">\(u \subseteq y\)</span> contains the empty set and is closed under <span class="math notranslate nohighlight">\(\mathit{succ}\)</span>. Then <span class="math notranslate nohighlight">\(u\)</span> is inductive, and since <span class="math notranslate nohighlight">\(y\)</span> is a subset of every inductive set, we have <span class="math notranslate nohighlight">\(y \subseteq u\)</span>. Since we assumed <span class="math notranslate nohighlight">\(u \subseteq y\)</span>, we have <span class="math notranslate nohighlight">\(u = y\)</span>, which is what we want.</p>
<p>To summarize, then, we have proved the existence of a set that contains <span class="math notranslate nohighlight">\(0\)</span> and is closed under a successor operation and satisfies the induction axiom. Moreover, there is only one such set: if <span class="math notranslate nohighlight">\(y_1\)</span> and <span class="math notranslate nohighlight">\(y_2\)</span> both have this property, then so does <span class="math notranslate nohighlight">\(y_1 \cap y_2\)</span>, and by the induction principle, this intersection has to be equal to both <span class="math notranslate nohighlight">\(y_1\)</span> and <span class="math notranslate nohighlight">\(y_2\)</span>, in which case <span class="math notranslate nohighlight">\(y_1\)</span> and <span class="math notranslate nohighlight">\(y_2\)</span> are equal. It then makes sense to call the unique set with these properties the <em>natural numbers</em>, and denote it by the symbol <span class="math notranslate nohighlight">\(\mathbb{N}\)</span>.</p>
<p>There is only one piece of the puzzle missing. It is clear from the definition that <span class="math notranslate nohighlight">\(0\)</span> is not the successor of any number, but it is not clear that the successor function is injective. We can prove that by first noticing that the natural numbers, as we have defined them, have a peculiar property: if <span class="math notranslate nohighlight">\(z\)</span> is a natural number, <span class="math notranslate nohighlight">\(y\)</span> is an element of <span class="math notranslate nohighlight">\(z\)</span>, and <span class="math notranslate nohighlight">\(x\)</span> is an element of <span class="math notranslate nohighlight">\(y\)</span>, then <span class="math notranslate nohighlight">\(x\)</span> is an element of <span class="math notranslate nohighlight">\(z\)</span>. This says exactly that the <span class="math notranslate nohighlight">\(\in\)</span> relation is transitive on natural numbers, which is not surprising, since we have noted that <span class="math notranslate nohighlight">\(\in\)</span> on the natural numbers, under our representation, coincides with <span class="math notranslate nohighlight">\(&lt;\)</span>. To prove this claim formally, say that a set <span class="math notranslate nohighlight">\(z\)</span> is <em>transitive</em> if it has the property just mentioned, namely, that every element of an element of <span class="math notranslate nohighlight">\(z\)</span> is an element of <cite>z</cite>. This is equivalent to saying that for every <span class="math notranslate nohighlight">\(y \in z\)</span>, we have <span class="math notranslate nohighlight">\(y \subseteq z\)</span>.</p>
<hr class="docutils" />
<p><strong>Lemma.</strong> Every natural number is transitive.</p>
<p><strong>Proof.</strong> By induction on the natural numbers. Clearly, <span class="math notranslate nohighlight">\(\emptyset\)</span> is transitive. Suppose <span class="math notranslate nohighlight">\(x\)</span> is transitive, and suppose <span class="math notranslate nohighlight">\(y \in \mathit{succ}(x)\)</span> and <span class="math notranslate nohighlight">\(z \in y\)</span>. Since <span class="math notranslate nohighlight">\(\mathit{succ}(x) = x \cup \{ x \}\)</span>, we have <span class="math notranslate nohighlight">\(y \in x\)</span> or <span class="math notranslate nohighlight">\(y \in \{x\}\)</span>. If <span class="math notranslate nohighlight">\(y \in x\)</span>, then by the inductive hypothesis, we have <span class="math notranslate nohighlight">\(z \in x\)</span>, and hence <span class="math notranslate nohighlight">\(z \in \mathit{succ}(x)\)</span>. Otherwise, we have <span class="math notranslate nohighlight">\(y \in \{ x \}\)</span>, and so <span class="math notranslate nohighlight">\(y = x\)</span>. In that case, again we have <span class="math notranslate nohighlight">\(z \in x\)</span>, and hence <span class="math notranslate nohighlight">\(z \in \mathit{succ}(x)\)</span>.</p>
<hr class="docutils" />
<p>The next lemma shows that, on transitive sets, union acts like the predecessor operation.</p>
<hr class="docutils" />
<p><strong>Lemma.</strong> If <span class="math notranslate nohighlight">\(x\)</span> is transitive, then <span class="math notranslate nohighlight">\(\bigcup \mathit{succ}(x) = x\)</span>.</p>
<p><strong>Proof</strong>. Suppose <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(\bigcup \mathit{succ}(x) = \bigcup (x \cup \{ x \})\)</span>. Then either <span class="math notranslate nohighlight">\(y \in z\)</span> for some <span class="math notranslate nohighlight">\(z \in x\)</span>, or <span class="math notranslate nohighlight">\(y \in x\)</span>. In the first case, also have <span class="math notranslate nohighlight">\(y \in x\)</span>, since <span class="math notranslate nohighlight">\(x\)</span> is transitive.</p>
<p>Conversely, suppose <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(x\)</span>. Then <span class="math notranslate nohighlight">\(y\)</span> is in <span class="math notranslate nohighlight">\(\bigcup \mathit{succ}(x)\)</span>, since we have <span class="math notranslate nohighlight">\(x \in \mathit{succ}(x)\)</span>.</p>
<p><strong>Theorem.</strong> <span class="math notranslate nohighlight">\(\mathit{succ}\)</span> is injective on <span class="math notranslate nohighlight">\(\mathbb{N}\)</span>.</p>
<p><strong>Proof.</strong> Suppose <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are in <span class="math notranslate nohighlight">\(\mathbb{N}\)</span>, and <span class="math notranslate nohighlight">\(\mathit{succ}(x) = \mathit{succ}(y)\)</span>. Then <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are both transitive, and we have <span class="math notranslate nohighlight">\(x = \bigcup \mathit{succ}(x) = \bigcup \mathit{succ}(y) = y\)</span>.</p>
<hr class="docutils" />
<p>With that, we are off and running. Although we will not present the details here, using the principle of induction we can justify the principle of recursive definition. We can then go on to define the basic operations of arithmetic and derive their properties, as done in <a class="reference internal" href="the_natural_numbers_and_induction.html#the-natural-numbers-and-induction"><span class="std std-numref">Chapter 17</span></a>. We can go on to define the integers, the rational numbers, and the real numbers, as described in Chapter <a class="reference internal" href="the_real_numbers.html#the-real-numbers"><span class="std std-numref">Chapter 21</span></a>, and to develop subjects like number theory and combinatorics, as described in Chapters <a class="reference internal" href="elementary_number_theory.html#elementary-number-theory"><span class="std std-numref">Chapter 19</span></a> and <a class="reference internal" href="combinatorics.html#combinatorics"><span class="std std-numref">Chapter 20</span></a>. In fact, it seems that any reasonable branch of mathematics can be developed formally on the basis of axiomatic set theory. There are pitfalls, for example, having to do with large collections: for example, just as it is inconsistent to postulate the existence of a set of all sets, in the same way, there is no collection of all partial orders, or all groups. So when interpreting some mathematical claims, care has to be taken in some cases to restrict to sufficiently large collections of such objects. But this rarely amounts to more than careful bookkeeping, and it is a remarkable fact that, for the most part, the axioms of set theory are flexible and powerful enough to justify most ordinary mathematical constructions.</p>
</div>
<div class="section" id="the-remaining-axioms">
<span id="id3"></span><h2><span class="section-number">23.3. </span>The Remaining Axioms<a class="headerlink" href="#the-remaining-axioms" title="Permalink to this headline">&#182;</a></h2>
<p>The seven axioms we have seen are quite powerful, and suffice to represent large portions of mathematics. We discuss the remaining axioms of Zermelo-Fraenkel set theory here.</p>
<p>So far, none of the axioms we have seen rule out the possibility that a set <span class="math notranslate nohighlight">\(x\)</span> can be an element of itself, that is, that we can have <span class="math notranslate nohighlight">\(x \in x\)</span>. The following axiom precludes that.</p>
<div class="math notranslate nohighlight">
\[\text{Foundation} \;\; \forall x \; (\exists y \; y \in x \to \exists y \in x \; \forall z \in x \; z \notin y)))\]</div>
<p>The axiom says that if <span class="math notranslate nohighlight">\(x\)</span> is a nonempty set, there is an element <span class="math notranslate nohighlight">\(y\)</span> of <span class="math notranslate nohighlight">\(x\)</span> with the property that no element of <span class="math notranslate nohighlight">\(y\)</span> is again an element of <span class="math notranslate nohighlight">\(x\)</span>. This implies we cannot have a descending chain of sets, each one an element of the one before:</p>
<div class="math notranslate nohighlight">
\[x_1 \ni x_2 \ni x_3 \ni \ldots\]</div>
<p>If we apply the axiom of foundation to the set <span class="math notranslate nohighlight">\(\{x_1, x_2, x_3, \ldots\}\)</span>, we find that some element <span class="math notranslate nohighlight">\(x_i\)</span> does not contain any others, which is only possible if the sequence has terminated with <span class="math notranslate nohighlight">\(x_i\)</span>. In other words, the axiom implies (and is in fact equivalent to) the statement that the elementhood relation is <em>well founded</em>, which explains the name.</p>
<p>The axioms listed in the previous section tell a story of how sets come to be: we start with the empty set, and keep applying constructions like power set, union, and separation, to build more sets. Set theorists often imagine the hierarchy of sets as forming a big V, with the empty set at the bottom and a set at any higher level comprising, as its elements, sets that appear in levels below. In a precise sense (which we will not spell out here), the axiom of foundation says that every set arises in such a way.</p>
<p>Now consider the following sequence of sets:</p>
<div class="math notranslate nohighlight">
\[\mathbb{N}, \;\; \mathcal P(\mathbb{N}), \;\; \mathcal P(\mathcal P(\mathbb{N}), \;\; \mathcal P (\mathcal P (\mathcal P (\mathbb{N}))), \;\; \ldots\]</div>
<p>It is consistent with all the axioms we have seen so far that every set in the mathematical universe is an element of one of these. That still gives us a lot of sets, but, since we have described that sequence, we can just as well imagine a set that contains all of them:</p>
<div class="math notranslate nohighlight">
\[\{ \mathbb{N}, \;\; \mathcal P(\mathbb{N}), \;\; \mathcal P(\mathcal P(\mathbb{N}), \;\; \mathcal P (\mathcal P (\mathcal P (\mathbb{N}))), \;\; \ldots \}.\]</div>
<p>The following axiom implies the existence of such a set.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{Replacement:} \;\; \forall x, y_1, \ldots, y_n \;\; (\forall z \in x \; \exists ! w \; A(z, w, y_1, \ldots, y_n) \rightarrow \\
\exists u \; \forall w \; (w \in u \leftrightarrow \exists z \in x \; A(z, w, y_1, \ldots, y_n)))\end{split}\]</div>
<p>Like the axiom of separation, this axiom is really a schema, which is to say, a separate axiom for each formula <span class="math notranslate nohighlight">\(A\)</span>. Here, too, the variables <span class="math notranslate nohighlight">\(y_1, y_2, \ldots, y_n\)</span> are free variables that can occur in <span class="math notranslate nohighlight">\(A\)</span>. To understand the axiom, it is easiest to think of them as parameters that are fixed in the background, and then ignore them. The axioms says that if, for every <span class="math notranslate nohighlight">\(z\)</span> in <span class="math notranslate nohighlight">\(x\)</span> there is a unique <span class="math notranslate nohighlight">\(w\)</span> satisfying <span class="math notranslate nohighlight">\(A(z,w)\)</span>, then there is a single set, <span class="math notranslate nohighlight">\(u\)</span>, that consists of the <span class="math notranslate nohighlight">\(w\)</span> values corresponding to every such <span class="math notranslate nohighlight">\(z\)</span>. In other words, if you think of <span class="math notranslate nohighlight">\(A\)</span> as a function whose domain is <span class="math notranslate nohighlight">\(x\)</span>, the axiom asserts that the range of that function exists. In the example above, <span class="math notranslate nohighlight">\(x\)</span> is the natural numbers, and <span class="math notranslate nohighlight">\(A(z, w)\)</span> says that <span class="math notranslate nohighlight">\(w\)</span> is the <span class="math notranslate nohighlight">\(z\)</span>-fold iterate of the power set of the natural numbers.</p>
<p>The nine axioms we have listed so far comprise what is known as <em>Zermelo-Fraenkel Set Theory</em>. There is on additional axiom, the axiom of choice, which is usually listed separately for historical reasons: it was once considered controversial, and in the early days, mathematicians considered it important to keep track of whether the axiom was actually used in a proof. There are many equivalent formulations, but this one is one of the most straightforward.</p>
<div class="math notranslate nohighlight">
\[\text{Choice:} \;\; \forall x \; (\emptyset \notin x \rightarrow \exists f : x \to \bigcup x \; \forall y \in x \; f(y) \in y)\]</div>
<p>The axiom says that for any collection <span class="math notranslate nohighlight">\(x\)</span> of nonempty sets, there is a function <span class="math notranslate nohighlight">\(f\)</span> that selects an element from each one. We used this axiom, informally, in <a class="reference internal" href="functions.html#injective-surjective-and-bijective-functions"><span class="std std-numref">Section 15.2</span></a> to show that every surjective function has a right inverse. In fact, this last statement can be shown to be equivalent to the axiom of choice on the basis of the other axioms.</p>
<p>To summarize, then, the axioms of Zermelo-Fraenkel Set Theory with the axiom of choice are as follows:</p>
<ol class="arabic">
<li><p>Extensionality:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\forall x, y \; (x = y \leftrightarrow \forall z (z \in x \leftrightarrow z \in y))\]</div>
</div></blockquote>
</li>
<li><p>Empty set:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\exists x \; \forall y \; y \notin x\]</div>
</div></blockquote>
</li>
<li><p>Pairing:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\forall x, y \; \exists z \; \forall w \; (w \in z \leftrightarrow w = x \vee w = y)\]</div>
</div></blockquote>
</li>
<li><p>Union:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\forall x \; \exists y \; \forall z \; (z \in y \leftrightarrow \exists w \; (w \in x \wedge z \in w))\]</div>
</div></blockquote>
</li>
<li><p>Power set:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\forall x \; \exists y \; \forall z \; (z \in y \leftrightarrow z \subseteq y)\]</div>
</div></blockquote>
</li>
<li><p>Separation:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\forall x_1, x_2, \ldots, x_n, y \; \exists z \; \forall w \; (w \in z \leftrightarrow w \in y \wedge A(w,x_1, x_2, \ldots, x_n))\]</div>
</div></blockquote>
</li>
<li><p>Infinity:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\exists x \; (\emptyset \in x \wedge \forall y \; (y \in x \rightarrow y \cup \{ y \} \in x))\]</div>
</div></blockquote>
</li>
<li><p>Foundation:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\forall x \; (\exists y \; y \in x \to \exists y \in x \; \forall z \in x \; z \notin y)))\]</div>
</div></blockquote>
</li>
<li><p>Replacement:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\forall x, y_1, \ldots, y_n \;\; (\forall z \in x \; \exists ! w \; A(z, w, y_1, \ldots, y_n) \rightarrow \\
\exists u \; \forall w \; (w \in u \leftrightarrow \exists z \in x \; A(z, w, y_1, \ldots, y_n)))\end{split}\]</div>
</div></blockquote>
</li>
<li><p>Choice:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\forall x \; (\emptyset \notin x \rightarrow \exists f : x \to \bigcup x \; \forall y \in x \; f(y) \in y)\]</div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="type-theory">
<h2><span class="section-number">23.4. </span>Type Theory<a class="headerlink" href="#type-theory" title="Permalink to this headline">&#182;</a></h2>
<p>As a foundation for mathematics, Zermelo-Fraenkel set theory is appealing. The underlying logic, first-order logic, provides the basic logical framework for quantifiers and the logical connectives. On top of that, the theory describes a single, intuitively natural concept, that of a set of elements. The axioms are plausible eminently reasonable. It is remarkable that virtually all of modern mathematics can be reduced to such simple terms.</p>
<p>There are other foundations on offer, however. These tend to be largely inter-interpretable with set theory. After all, set-theoretic language is now ubiquitous in everyday mathematics, so any reasonable foundation should be able to make sense of such language. On the other hand, we have already noted that set theory is remarkably expressive and robust, and so it should not be surprising that other foundational approaches can often be understood in set-theoretic terms.</p>
<p>This is, in particular, true of <em>dependent type theory</em>, which is the basis of the Lean theorem prover. The syntax of type theory is more complicated than that of set theory. In set theory, there is only one kind of object; officially, everything is a set. In contrast, in type theory, every well-formed expression in Lean has a <em>type</em>, and there is a rich vocabulary of defining types.</p>
<p>In fact, Lean is based on a version of an axiomatic framework known as the <em>Calculus of Inductive Constructions</em>, which provides all of the following:</p>
<ul class="simple">
<li><p>A hierarchy of <em>type universes</em>, <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">2</span></code>, &#8230; and a special type <code class="docutils literal notranslate"><span class="pre">Prop</span></code>. The expression <code class="docutils literal notranslate"><span class="pre">Type</span></code> abbreviates <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">0</span></code>, and saying <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">:</span> <span class="pre">Type</span></code> can be interpreted as saying that <code class="docutils literal notranslate"><span class="pre">T</span></code> is a datatype. The type <code class="docutils literal notranslate"><span class="pre">Prop</span></code> is the type of propositions.</p></li>
<li><p><em>Dependent function types</em> <code class="docutils literal notranslate"><span class="pre">&#928;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">A,</span> <span class="pre">B</span> <span class="pre">x</span></code>. An element <code class="docutils literal notranslate"><span class="pre">f</span></code> of this type is a function which maps any element <code class="docutils literal notranslate"><span class="pre">a</span></code> of type <code class="docutils literal notranslate"><span class="pre">A</span></code> to an element <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code> of type <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">a</span></code>. The fact that the type of the output depends on the type of the input is what makes the function &#8220;dependent.&#8221; In the case where the output type does not depend on the input, we have the simple function type <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8594;</span> <span class="pre">B</span></code>.</p></li>
<li><p><em>Inductive types</em>, like the natural numbers, specified by <em>constructors</em>, like zero and successor. Each such type comes with principles of induction and recursion.</p></li>
</ul>
<p>These constructions account for both the underlying logic of assertions (that is, the propositions) as well as the objects of the universe, which are elements of the ordinary types.</p>
<p>It is straightforward to interpret type theory in set theory, since we can view each type as a set. The type universes are simply large collections of sets, and dependent function types and inductive types can be explained in terms of set-theoretic constructions. We can view <code class="docutils literal notranslate"><span class="pre">Prop</span></code> as the set <span class="math notranslate nohighlight">\(\{ \top, \bot \}\)</span> of truth values, just as we did when we described truth-table semantics for propositional logic.</p>
<p>Given this last fact, why not just use set theory instead of type theory for interactive theorem proving? Some interactive theorem provers do just that. But type theory has some advantages:</p>
<ul class="simple">
<li><p>The fact that the rules for forming expressions are so rigid makes it easier for the system to recognize typographical errors and provide useful feedback. In type theory, if <code class="docutils literal notranslate"><span class="pre">f</span></code> has type <code class="docutils literal notranslate"><span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8469;</span></code> it can be applied only to a natural number, and a theorem prover can flag an error if the argument has the wrong type. In set theory, anything can be applied to anything, whether or not doing so really makes sense.</p></li>
<li><p>Again, because the rules for forming expressions are so rigid, the system can infer useful information from the components of an expression, whereas set theory would require us to make such information explicit. For example, with <code class="docutils literal notranslate"><span class="pre">f</span></code> as above, a theorem prover can infer that a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> should have type <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code>, and that the resulting expression again has type <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code>. In set theory, <span class="math notranslate nohighlight">\(x \in \mathbb{N}\)</span> has to be stated as an explicit hypothesis, and <span class="math notranslate nohighlight">\(f(x) \in \mathbb{N}\)</span> is then a theorem.</p></li>
<li><p>By encoding propositions as certain kinds of types, we can use the same language for defining mathematical objects and writing mathematical proofs. For example, we can apply a function to an argument in the same way we apply a theorem to some hypotheses.</p></li>
<li><p>Expressions in a sufficiently pure part of dependent type theory have a computational interpretation, so, for example, the logical framework tells us how to evaluate the factorial function, given its definition. In set theory, the computational interpretation is specified independently, after the fact.</p></li>
</ul>
<p>These facts hark back to the separation of concerns that we raised in <a class="reference internal" href="introduction.html#introduction"><span class="std std-numref">Chapter 1</span></a>: different axiomatic foundations provide different idealized descriptions of mathematical activity, and can be designed to serve different purposes. If you want a clean, simple theory that accounts for the vast majority of mathematical proof, set theory is hard to beat. If you are looking for a foundation that makes computation central or takes the notion of a function rather than a set as basic, various flavors of type theory have their charms. For interactive theorem proving, pragmatic issues regarding implementation and usability come into play. What is important to recognize is that what all these idealized descriptions have in common is that they are all designed to model important aspects of mathematical language and proof. Our goal here has been to help you reflect on those features of mathematical language and proof that give mathematics its special character, and to help you better understand how they work.</p>
</div>
<div class="section" id="exercises">
<h2><span class="section-number">23.5. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">&#182;</a></h2>
<ol class="arabic simple">
<li><p>Use an argument similar Russell&#8217;s paradox to show that there is no &#8220;set of all sets,&#8221; that is, there is no set that contains every other set as an element.</p></li>
<li><p>Suppose <span class="math notranslate nohighlight">\(x\)</span> is a nonempty set, say, containing an element <span class="math notranslate nohighlight">\(y\)</span>. Use the axiom of separation to show that the set <span class="math notranslate nohighlight">\(\bigcap x\)</span> exists. (Remember that something is an element of <span class="math notranslate nohighlight">\(\bigcap x\)</span> if it is an element of every element of <span class="math notranslate nohighlight">\(x\)</span>.)</p></li>
<li><p>Justify the claim in <a class="reference internal" href="#basic-axioms-for-sets"><span class="std std-numref">Section 23.1</span></a> that every element of <span class="math notranslate nohighlight">\(x \times y\)</span> is an element of <span class="math notranslate nohighlight">\(\mathcal P (\mathcal P (x \cup y))\)</span>.</p></li>
<li><p>Given a set <span class="math notranslate nohighlight">\(x\)</span> and a function <span class="math notranslate nohighlight">\(A : x \to y\)</span>, use the axioms of set theory to prove the existence of <span class="math notranslate nohighlight">\(\bigcup_{i \in x} A(i)\)</span>.</p></li>
</ol>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Logic and Proof</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic.html">2. Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_propositional_logic.html">3. Natural Deduction for Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositional_logic_in_lean.html">4. Propositional Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="classical_reasoning.html">5. Classical Reasoning</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_propositional_logic.html">6. Semantics of Propositional Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic.html">7. First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="natural_deduction_for_first_order_logic.html">8. Natural Deduction for First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="first_order_logic_in_lean.html">9. First Order Logic in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="semantics_of_first_order_logic.html">10. Semantics of First Order Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets.html">11. Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="sets_in_lean.html">12. Sets in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations.html">13. Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="relations_in_lean.html">14. Relations in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">15. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="functions_in_lean.html">16. Functions in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction.html">17. The Natural Numbers and Induction</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_natural_numbers_and_induction_in_lean.html">18. The Natural Numbers and Induction in Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="elementary_number_theory.html">19. Elementary Number Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="combinatorics.html">20. Combinatorics</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_real_numbers.html">21. The Real Numbers</a></li>
<li class="toctree-l1"><a class="reference internal" href="the_infinite.html">22. The Infinite</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">23. Axiomatic Foundations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-axioms-for-sets">23.1. Basic Axioms for Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-axiom-of-infinity">23.2. The Axiom of Infinity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-remaining-axioms">23.3. The Remaining Axioms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-theory">23.4. Type Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">23.5. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nd_quickref.html">24. Appendix: Natural Deduction Rules</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="logic_and_proof.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Robert Y. Lewis, and Floris van Doorn.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/axiomatic_foundations.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>